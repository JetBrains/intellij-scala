### org/jetbrains/plugins/scala/debugger/ScalaFrameExtraVariablesProvider.scala
debug.process.is.detached=Debug process is detached.

### org/jetbrains/plugins/scala/debugger/breakpoints/ScalaLineBreakpointType.scala
line.breakpoints.tab.title=Scala Line Breakpoints
breakpoint.location.constructor.of=constructor of {0}
breakpoint.location.early.definitions.of=early definitions of {0}
breakpoint.location.line.in.containing.block=line in containing block
breakpoint.location.line.in.function=line in function {0}
breakpoint.location.line.in.containing.file=line in containing file

### org/jetbrains/plugins/scala/debugger/evaluation/ExpressionCompilerResolverListener.scala
resolving.expression.compiler=Debugger: Resolving Scala expression compiler

### org/jetbrains/plugins/scala/debugger/evaluation/ScalaEvaluatorBuilder.scala
evaluation.of.object.needs.compilation=Evaluation of object needs compilation
evaluation.of.class.needs.compilation=Evaluation of class needs compilation
evaluation.of.trait.needs.compilation=Evaluation of trait needs compilation
evaluation.of.anonymous.class.needs.compilation=Evaluation of anonymous class needs compilation
evaluation.of.type.alias.needs.compilation=Evaluation of type alias needs compilation
evaluation.of.function.definition.needs.compilation=Evaluation of function definition needs compilation
evaluation.of.variable.declaration.needs.compilation=Evaluation of variable declaration needs compilation
evaluation.of.lazy.val.definition.needs.compilation=Evaluation of lazy val definition needs compilation
evaluation.of.anonymous.function.needs.compilation=Evaluation of anonymous function needs compilation
evaluation.of.for.expression.needs.compilation=Evaluation of for expression needs compilation
evaluation.of.try.statement.needs.compilation=Evaluation of try statement needs compilation
evaluation.of.return.statement.needs.compilation=Evaluation of return statement needs compilation
evaluation.of.match.statement.needs.compilation=Evaluation of match statement needs compilation
evaluation.of.throw.statement.needs.compilation=Evaluation of throw statement needs compilation
evaluation.of.xml.expression.needs.compilation=Evaluation of xml expression needs compilation
evaluation.of.interpolated.string.needs.compilation=Evaluation of interpolated string needs compilation
cannot.find.by.name.parameter.with.such.name=Cannot find by-name parameter with such name: {0}
evaluation.of.expression.is.not.supported=Evaluation of expression is not supported: {0}
evaluation.of.element.is.not.supported=Evaluation of element is not supported: {0}

### org/jetbrains/plugins/scala/debugger/evaluation/ScalaEvaluatorBuilderUtil.scala
cannot.evaluate.imported.reference=Cannot evaluate imported reference
cannot.evaluate.local.method=Cannot evaluate local method
cannot.evaluate.parameter=Cannot evaluate parameter {0}
cannot.evaluate.method=Cannot evaluate method {0}
cannot.evaluate.local.object=Cannot evaluate local object {0}
cannot.evaluate.local.variable=Cannot evaluate local variable {0}
wrong.number.of.arguments=Wrong number of arguments for method {0}
array.instance.is.not.found=Cannot evaluate method {0}: array instance is not found
array.method.not.supported=Array method not supported
cannot.find.implicit.parameters=Cannot find implicit parameters to pass
implicit.parameters.from.dependent.objects=Implicit parameters from dependent objects are not supported
implicit.conversions.from.dependent.objects=Implicit conversions from dependent objects are not supported
method.with.by-name.parameters=Cannot evaluate methods with by-name parameters
wrong.number.of.expressions=Cannot evaluate arguments: wrong number of matched expressions
tupling.not.supported=Tupling is not supported. Use tuple expression.
not.used.from.for.statement=Cannot evaluate variable {0} from a for-statement because it was not used in the body
cannot.find.pattern=Cannot find pattern of case clause
cannot.find.expression.of.match=Cannot find expression of match statement
invalid.case.clause=Invalid case clause
assignent.without.expression=Cannot evaluate assign statement without expression
unapply.without.arguments=Cannot extract value from unapply without arguments
pattern.doesnot.resolves.to.unapply=Pattern reference {0} does not resolve to unapply or unapplySeq
pattern.alternatives.cannot.bind.vars=Pattern alternatives cannot bind variables
xml.patterns.not.supported=Xml patterns are not supported
kind.of.pattern.not.supported=This kind of pattern is not supported: {0}
anon.classes.not.supported=Anonymous classes are not supported
new.expression.without.class.reference=Cannot evaluate new expression without class reference
new.expression.without.constructor.call=Cannot evaluate expression without constructor call
new.expression.without.template.parents=Cannot evaluate expression without template parents
could.not.resolve.constructor=Could not resolve constructor
if.statement.without.condition=Cannot evaluate if statement without condition
if.statement.without.if.branch=Cannot evaluate if statement without if branch
while.statement.without.condition=Cannot evaluate while statement without condition
while.statement.without.body=Cannot evaluate while statement without body
do.statement.without.condition=Cannot evaluate do statement without condition
do.statement.without.body=Cannot evaluate do statement without body
method.call.implicitly.converted.qualifier=Cannot evaluate method call with implicitly converted qualifier: {0}
synchronized.statement.is.not.supported=synchronized statement is not supported
cannot.evaluate.synthetic.method=Cannot evaluate synthetic method: {0}
by.name.parameter.expected=By-name parameter expected
update.method.is.not.supported=Update method is not supported
variable.definition.needs.right.hand.side=Variable definition needs right-hand side: {0}
value.definition.needs.right.hand.side=Value definition needs right-hand side: {0}
new.synthetic.instantiation={0} ''{1}'' is abstract; cannot be instantiated
missing.type.argument.synthetic.method={0} called without an explicit type argument
constructor.param.inaccessible.outside.of.constructor=constructor parameter ''{0}'' is inaccessible outside the class constructor
array.constructor.unspecified.parameters=Unspecified value parameters: _length: Int
array.constructor.too.many.arguments=Too many arguments for constructor Array(Int)

### org/jetbrains/plugins/scala/debugger/evaluation/ScalaEvaluatorCompileHelper.scala
could.not.compile=Could not compile:\n{0}
compilation.failed=Compilation failed

### org/jetbrains/plugins/scala/debugger/evaluation/evaluator/AsInstanceOfEvaluator.scala
error.cannot.cast.value.to.type=Cannot cast value of type ''{0}'' to type ''{1}''

### org/jetbrains/plugins/scala/debugger/evaluation/evaluator/ClassOfEvaluator.scala
error.literal.type.is.not.class.type=Literal type ({0} : {1}) is not a class type

### org/jetbrains/plugins/scala/debugger/evaluation/evaluator/ExpressionCompilerEvaluator.scala
could.not.determine.scala.version=Could not determine the configured Scala version for module {0}
could.not.resolve.scala.expression.compiler=Could not resolve the Scala expression compiler version {0} for Scala {1}. Check that the Scala expression compiler has been published for that specific Scala version. Restarting the debugger should retry the artifact resolution.
expression.compilation.failed=Expression compilation failed: ${0}

### org/jetbrains/plugins/scala/debugger/evaluation/evaluator/IsInstanceOfEvaluator.scala
error.type.cannot.be.used.in.isinstanceof={0} {1} cannot be used in runtime type tests
error.value.isinstanceof.reference=cannot test if value of type {0} is a reference of type {1}
error.isinstanceof.structural.type=A runtime type test on structural types is unchecked

### org/jetbrains/plugins/scala/debugger/evaluation/evaluator/NewValueClassInstanceEvaluator.scala
error.cannot.resolve.value.class.primary.constructor=Cannot resolve the primary constructor of value class {0}

### org/jetbrains/plugins/scala/debugger/evaluation/evaluator/PartialFunctionPatternEvaluator.scala
error.no.synthetic.arguments.found=No compiler generated arguments found
error.cannot.evaluate.more.than.22.synthetic.arguments=Cannot evaluate more than 22 compiler generated arguments

### org/jetbrains/plugins/scala/debugger/evaluation/evaluator/ScalaBoxingEvaluator.scala
cannot.perform.boxing.conversion.for.result=Cannot perform boxing conversion for {0}

### org/jetbrains/plugins/scala/debugger/evaluation/evaluator/ScalaCompilingEvaluator.scala
could.not.compile.generated.class=Could not compile generated class
error.during.generated.code.invocation=Error during generated code invocation:\n {0}
error.creating.evaluation.class.loader=Error creating evaluation class loader:\n {0}
error.during.classes.definition=Error during classes definition:\n {0}

### org/jetbrains/plugins/scala/debugger/evaluation/evaluator/ScalaLiteralEvaluator.scala
unknown.type.of.literal=unknown type of literal
literal.has.null.value=Literal {0} has null value

### org/jetbrains/plugins/scala/debugger/evaluation/evaluator/ScalaMethodEvaluator.scala
could.not.find.appropriate.constructor.for.name=Couldn''t find appropriate constructor for {0}
cannot.invoke.abstract.interface.method.name=Cannot invoke abstract interface method {0}
method.methodname.cannot.be.invoked.on.array=Method {0} cannot be invoked on array

### org/jetbrains/plugins/scala/debugger/evaluation/evaluator/ScalaThisEvaluator.scala
outer.this.not.available=Outer `this` is not available

### org/jetbrains/plugins/scala/debugger/evaluation/evaluator/compiling/GeneratedClass.scala
module.for.compilation.is.not.found=Module for compilation is not found
could.not.evaluate.due.to.a.change.in.a.source.file=Could not evaluate due to a change in a source file
could.not.compile.local.class.in.this.context=Could not compile local class in this context

### org/jetbrains/plugins/scala/debugger/filters/ScalaDebuggerSettingsConfigurable.form
friendly.collection.display.enabled=Friendly display of Scala collections in debugger
dont.show.runtime.refs=Do not show runtime refs in debugger
show.variables.from.outer.scopes.in.variables.view=Show variables from outer scopes in variables view

### org/jetbrains/plugins/scala/debugger/filters/ScalaDebuggerSettingsConfigurable.java
scala.debug.caption=Scala

### org/jetbrains/plugins/scala/debugger/filters/ScalaSteppingConfigurable.form
scala.debug.disable.specific.methods=Do not step &into specific Scala classes

### org/jetbrains/plugins/scala/debugger/ui/ScalaClassRenderer.scala
scala.class.renderer=Scala object

### org/jetbrains/plugins/scala/debugger/ui/ScalaCollectionRenderer.scala
scala.collection.renderer=Scala collection

### org/jetbrains/plugins/scala/debugger/ui/ScalaRuntimeRefRenderer.scala
scala.runtime.ref.renderer=Scala runtime reference

### org/jetbrains/plugins/scala/debugger/ui/descriptors.scala
could.not.find.bitmap.field=Could not find bitmap field {0}
could.not.find.accessor.method=Could not find accessor method for field {0}
initialize.lazy.val=Initialize
lazy.val.not.initialized=<not initialized>
collection.element.descriptors.evaluation.not.supported="Evaluation of collection element descriptors is not supported"
