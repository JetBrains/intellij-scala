package org.jetbrains.plugins.scala.compiler.highlighting

import com.intellij.openapi.project.Project
import com.intellij.openapi.roots.{ProjectFileIndex, ProjectRootManager}
import com.intellij.openapi.vfs.AsyncFileListener
import com.intellij.openapi.vfs.newvfs.events.{VFileDeleteEvent, VFileEvent}
import com.intellij.problems.WolfTheProblemSolver
import org.jetbrains.plugins.scala.compiler.highlighting.BackgroundExecutorService.executeOnBackgroundThreadInNotDisposed
import org.jetbrains.plugins.scala.extensions.inReadAction
import org.jetbrains.plugins.scala.settings.ScalaHighlightingMode

import scala.jdk.CollectionConverters._

private final class CompilerHighlightingFileListener(project: Project) extends AsyncFileListener {

  private val fileIndex: ProjectFileIndex = ProjectRootManager.getInstance(project).getFileIndex

  override def prepareChange(events: java.util.List[_ <: VFileEvent]): AsyncFileListener.ChangeApplier = {
    if (!ScalaHighlightingMode.isShowErrorsFromCompilerEnabled(project)) {
      // Compiler Based Highlighting is not enabled in this project. Nothing to do.
      return null
    }

    val files = events.asScala.collect { case event: VFileDeleteEvent => event.getFile }.toSeq
    val deletedFiles = inReadAction { files.filter(fileIndex.isInSourceContent) }

    if (deletedFiles.isEmpty) {
      // No removed files. Nothing to do.
      return null
    }

    new AsyncFileListener.ChangeApplier {
      override def afterVfsChange(): Unit = {
        executeOnBackgroundThreadInNotDisposed(project) {
          // Remove errors generated by Compiler Based Highlighting that have previously been reported to the Wolf
          // for all removed files. This must be done on a background thread.
          val wolf = WolfTheProblemSolver.getInstance(project)
          val source = ExternalHighlightersService.instance(project)
          deletedFiles.foreach(wolf.clearProblemsFromExternalSource(_, source))
        }
      }
    }
  }
}
