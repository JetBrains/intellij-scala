### org/jetbrains/plugins/scala/DesktopUtils.scala
title.problem.opening.web.page=Problem opening web page
html.unable.to.launch.web.browser=\
  <html>\
  <body>\
  Unable to launch web browser, please manually open:<br />\
  {0} (<a href="{0}">copy to clipboard</a>)\
  </body>\
  </html>

### org/jetbrains/plugins/scala/actions/EditPackagePrefixAction.scala
edit.package.prefix=Edit Package Prefix...

### org/jetbrains/plugins/scala/actions/MakeExplicitAction.scala
make.implicit.conversion.explicit.action.text=Make implicit conversion explicit
make.implicit.conversion.explicit.action.description=Make implicit conversion explicit
title.choose.implicit.conversion.method=Choose implicit conversion method:
press.alt.enter=Press Alt+Enter
make.explicit=Make explicit
make.explicit.and.import.method=Make explicit (Import method)

### org/jetbrains/plugins/scala/actions/NewPackageObjectAction.scala
new.packageobject.menu.action.text=Package Object
new.packageobject.menu.action.description=Create new Scala package object

### org/jetbrains/plugins/scala/actions/NewScalaTypeDefinitionAction.scala
newclass.menu.action.text=Scala Class
newclass.menu.action.description=Creates new Scala Class
create.new.scala.class=Create New Scala Class
this.is.not.a.valid.scala.qualified.name=This is not a valid Scala qualified name

### org/jetbrains/plugins/scala/actions/ScalaExpressionTypeProvider.scala
no.expression.found=No expression found
type.hint.table.title.type=Type
type.hint.table.title.dealiased=Dealiased
type.hint.table.title.widened=Widened
type.hint.table.title.expected=Expected
type.hint.table.title.without.implicits=Without implicits
unknown.type=<unknown>

### org/jetbrains/plugins/scala/actions/ShowTypeInfoAction.scala
type.info.text=Type Info
type.info.description=Show Type Info
could.not.find.type.for.selection=Could not find type for selection
hint.label.non.singleton=Non-singleton
hint.label.simplified=Simplified
hint.label.original=Original
hint.label.expected=Expected

### org/jetbrains/plugins/scala/actions/ToggleTypeAwareHighlightingAction.scala
toggle.type.aware.highlighting.menu.action.text=Toggle Type Aware Highlighting
toggle.type.aware.highlighting.menu.action.description=Toggle Type Aware Highlighting

### org/jetbrains/plugins/scala/actions/implicitArguments/ImplicitArgumentNodes.scala
implicit.argument.is.applicable=Implicit argument is applicable
implicit.is.diverged=Implicit is diverged
can.t.infer.proper.types.for.type.parameters=Can't infer proper types for type parameters
can.t.find.implicit.argument.for.this.definition=Can't find implicit argument for this definition
no.implicits.applicable.by.type=No implicits applicable by type
reason.prefix.applicable=Applicable: 
reason.prefix.diverged=Diverged: 
reason.prefix.cannot.infer.type=Cannot infer type: 
reason.prefix.candidate=Candidate: 
problem.prefix.ambiguous=(Ambiguous)
problem.prefix.not.found=(Not found)
location.description.parameter.of.name=parameter of {0}
location.description.parameter.of.getclassnametext=parameter of {0}
location.description.anonymous.class=anonymous class
location.description.containing.block=containing block
location.description.body.of.name=body of {0}

### org/jetbrains/plugins/scala/actions/implicitArguments/ShowImplicitArgumentsAction.scala
show.implicit.arguments.action.text=Show implicit arguments
show.implicit.arguments.action.description=Show implicit arguments
no.implicit.arguments=No implicit arguments
title.expressions=Expressions
navigate=Navigate
implicit.arguments.for.implicit.conversion=Implicit arguments for implicit conversion:
implicit.arguments=Implicit arguments:

### org/jetbrains/plugins/scala/actions/implicitConvertions/ShowImplicitConversionsAction.scala
implicit.conversions.action.text=Show implicit conversions
implicit.conversions.action.description=Show implicit conversions

### org/jetbrains/plugins/scala/actions/internal/ScalaCollectShortTroubleshootingInfoAction.scala
scala.collect.troubleshooting.information.short.action.text=(Scala) Collect Troubleshooting Information Short
scala.collect.troubleshooting.information.short.action.description=Collect Scala Plugin and IntelliJ IDEA versions to quickly paste them to YouTrack
short.troubleshooting.summary.copied.to.your.clipboard.with.summary=Short troubleshooting summary copied to your clipboard\n{0}

### org/jetbrains/plugins/scala/annotator/AnnotatorUtils.scala
# TODO unify type mismatch messages
type.mismatch.found.required=Type mismatch, found: {0}, required: {1}
# TODO unify type mismatch messages
type.mismatch.expected.actual=Type mismatch, expected: {0}, actual: {1}
abstract.member.not.have.private.modifier=Abstract member may not have private modifier
illegal.inheritance.from.sealed.kind=Illegal inheritance from sealed {0} ''{1}''

### org/jetbrains/plugins/scala/annotator/ByNameParameter.scala
passed.as.by.name.parameter=Passed as by-name parameter

### org/jetbrains/plugins/scala/annotator/FunctionAnnotator.scala
function.must.define.type.explicitly=Method {0} has return statement; needs result type
function.recursive.need.result.type=Recursive method {0} needs result type
family.name.remove.tailrec.annotation=Remove @tailrec annotation
method.annotated.with.tailrec.is.neither.private.nor.final=Method annotated with @tailrec is neither private nor final (so can be overridden)
method.annotated.with.tailrec.contains.no.recursive.calls=Method annotated with @tailrec contains no recursive calls
recursive.call.not.in.tail.position=Recursive call not in tail position (in @tailrec annotated method)

### org/jetbrains/plugins/scala/annotator/OverridingAnnotator.scala
member.needs.override.modifier={0} ''{1}'' needs override modifier
member.overrides.nothing={0} ''{1}'' overrides nothing
can.not.override.final={0} ''{1}'' cannot override final member
member.cannot.override.var=method {0} cannot override a mutable variable
member.cannot.override.val=method {0} needs to be a stable, immutable value
var.cannot.override.val=variable {0} cannot override immutable value
override.types.not.conforming=Overriding type {0} does not conform to base type {1}

### org/jetbrains/plugins/scala/annotator/ScalaAnnotator.scala
covariant.type.contravariant.position.of.method=Covariant type {0} occurs in contravariant position in type {1} of method {2}
covariant.type.contravariant.position.of.value=Covariant type {0} occurs in contravariant position in type {1} of value {2}
covariant.type.invariant.position.of.method=Covariant type {0} occurs in invariant position in type {1} of method {2}
covariant.type.invariant.position.of.value=Covariant type {0} occurs in invariant position in type {1} of value {2}
contravariant.type.covariant.position.of.method=Contravariant type {0} occurs in covariant position in type {1} of method {2}
contravariant.type.covariant.position.of.value=Contravariant type {0} occurs in covariant position in type {1} of value {2}
contravariant.type.invariant.position.of.method=Contravariant type {0} occurs in invariant position in type {1} of method {2}
contravariant.type.invariant.position.of.value=Contravariant type {0} occurs in invariant position in type {1} of value {2}

### org/jetbrains/plugins/scala/annotator/ScopeAnnotator.scala
id.is.already.defined={0} is already defined in the scope

### org/jetbrains/plugins/scala/annotator/TypeMismatchError.scala
# TODO unify type mismatch messages
type.mismatch.message=Type mismatch. Required: {0}, found: {1}

### org/jetbrains/plugins/scala/annotator/TypeMismatchToggleAction.scala
type.mismatch.hints.action.text=Type mismatch hints
type.mismatch.hints.action.description=Toggle type mismatch hints

### org/jetbrains/plugins/scala/annotator/createFromUsage/CreateApplyQuickFix.scala
family.name.create.apply.method=Create 'apply' method
create.apply.method.in=Create ''apply'' method in {0}

### org/jetbrains/plugins/scala/annotator/createFromUsage/CreateEntityQuickFix.scala
error.message.title.create.entity.quickfix=Create entity quickfix

### org/jetbrains/plugins/scala/annotator/createFromUsage/CreateExtractorObjectQuickFix.scala
family.name.create.extractor.object=Create extractor object
create.extractor.object.named=Create extractor object ''{0}''

### org/jetbrains/plugins/scala/annotator/createFromUsage/CreateParameterlessMethodQuickFix.scala
family.name.create.parameterless.method=Create parameterless method
create.parameterless.method.named=Create parameterless method ''{0}''
family.name.create.variable=Create variable
create.variable.named=Create variable ''{0}''
family.name.create.value=Create value
create.value.named=Create value ''{0}''
family.name.create.method=Create method
create.method.named=Create method ''{0}''

### org/jetbrains/plugins/scala/annotator/createFromUsage/CreateTypeDefinitionQuickFix.scala
family.name.create.object=Create object
family.name.create.trait=Create trait
family.name.create.class=Create class
family.name.create.case.class=Create case class
create.object.named=Create object ''{0}''
create.trait.named=Create trait ''{0}''
create.class.named=Create class ''{0}''
create.case.class.named=Create case class ''{0}''
choose.level.popup.title=Choose level
new.class.location.new.file=New file
new.class.location.top.level.in.this.file=Top level in this file
new.class.location.inner.in.class=Inner in {0}
new.class.location.local.scope=Local scope

### org/jetbrains/plugins/scala/annotator/createFromUsage/CreateUnapplyQuickFix.scala
family.name.create.unapply.method=Create 'unapply' method
create.unapply.method.in=Create ''unapply'' method in {0}

### org/jetbrains/plugins/scala/annotator/element/ScAnnotationAnnotator.scala
scala.meta.recompile=Metaprogram is out of date. Click here to compile
scala.meta.expandfailed=Macro expansion failed: {0}

### org/jetbrains/plugins/scala/annotator/element/ScAssignmentAnnotator.scala
annotator.error.wrong.right.assignment.side=Wrong right assignment side
annotator.error.reassignment.to.val=Reassignment to val
illegal.assignment.target=Illegal assignment target

### org/jetbrains/plugins/scala/annotator/element/ScCatchBlockAnnotator.scala
# TODO unify type mismatch messages
expr.type.does.not.conform.expected.type=Expression of type {0} doesn''t conform to expected type {1}
method.is.not.member=Method {0} is not a member of type {1}
expected.type.boolean=Expected type Boolean as method {0} return type

### org/jetbrains/plugins/scala/annotator/element/ScClassAnnotator.scala
illegal.secondary.constructors.value.class=Secondary constructors are not allowed in value classes
value.class.can.have.only.one.parameter=Value classes can have only one parameter
value.class.can.have.only.val.parameter=Value classes can have only one non-private val parameter
type.parameter.value.class.may.not.be.specialized=Type parameter of value class may not be specialized
value.classes.cannot.have.nested.objects=Value classes cannot have nested classes, objects or traits
value.classes.cannot.redefine.equals.hashcode=Value classes cannot redefine equals and hashCode
value.classes.can.have.only.defs=Field definitions are not allowed in value classes
value.classes.may.not.be.member.of.another.class=Value class may not be member of another class

### org/jetbrains/plugins/scala/annotator/element/ScConstrBlockExprAnnotator.scala
constructor.invocation.expected=Auxiliary constructor must begin with call to 'this'

### org/jetbrains/plugins/scala/annotator/element/ScConstructorInvocationAnnotator.scala
# TODO unify type mismatch messages
type.mismatch.default.args.expected.actual=Type mismatch involving default arguments, expected: {0}, actual: {1}
annotator.error.class.type.required.but.found=Class type required but ({0}) found
annotator.error.constructor.has.malformed.definition=Constructor has malformed definition
annotator.error.no.constructor.accessible=No constructor accessible from here
annotator.error.cannot.resolve.overloaded.constructor=Cannot resolve overloaded constructor `{0}`
annotator.error.unspecified.value.parameters=Unspecified value parameters: {0}
annotator.error.trait.has.no.constructor=trait {0} is a trait; does not take constructor arguments
annotator.error.too.many.arguments.for.constructor=Too many arguments for constructor {0}
annotator.error.missing.argument.list.for.constructor=Missing argument list for constructor {0}
annotator.error.expansion.for.non.repeated.parameter=Expansion for non-repeated parameter
annotator.error.positional.after.named.argument=Positional after named argument
annotator.error.parameter.specified.multiple.times=Parameter specified multiple times
annotator.error.cannot.apply.constructor=Cannot apply constructor {0}

### org/jetbrains/plugins/scala/annotator/element/ScEnumCaseAnnotator.scala
annotator.error.enum.nonvariant.type.param,in.enum=Cannot determine type argument for enum class parent {0}, type parameter {1} is invariant
annotator.error.enum.case.must.extend.parent=Enum case must extend its enum class {0}
annotator.error.enum.two.type.parameter.clauses=Explicit extends clause required because both enum case and enum class have type parameters

### org/jetbrains/plugins/scala/annotator/element/ScEnumeratorsAnnotator.scala
semicolon.not.allowed.here=Semicolon not allowed here
remove.all.erroneous.semicolons.from.forexpression=Remove all erroneous semicolons from for expression

### org/jetbrains/plugins/scala/annotator/element/ScForBindingAnnotator.scala
enumerators.binding.val.keyword.deprecated='val' keyword in enumerators is deprecated
enumerators.binding.case.keyword.found=Expected pattern, but 'case' was found
remove.case=Remove 'case'
family.name.remove.case.from.enumerator=Remove 'case' from enumerator

### org/jetbrains/plugins/scala/annotator/element/ScFunctionExprAnnotator.scala
annotator.error.too.many.parameters=Too many parameters
annotator.error.missing.parameter.type=Missing parameter type
type.mismatch.expected=Type mismatch, expected: {0}, actual: {1}

### org/jetbrains/plugins/scala/annotator/element/ScFunctionalTypeElementAnnotator.scala
repeated.param.non.method=Repeated parameters are only allowed in method signatures. Use `Seq` instead

### org/jetbrains/plugins/scala/annotator/element/ScGeneratorAnnotator.scala
for.pattern.bindings.require.scala3='case' syntax in 'for' pattern bindings requires Scala 3.0
enumerators.generator.val.keyword.found=Expected pattern, but 'val' was found

### org/jetbrains/plugins/scala/annotator/element/ScImportExprAnnotator.scala
import.expr.should.be.qualified=Import expression must be qualified

### org/jetbrains/plugins/scala/annotator/element/ScInterpolatedStringLiteralAnnotator.scala
cannot.resolve.in.StringContext=Value ''{0}'' is not a member of StringContext

### org/jetbrains/plugins/scala/annotator/element/ScLiteralTypeElementAnnotator.scala
wrong.type.no.literal.types=Wrong type `{0}`, for literal types support use Scala 2.13 or Typelevel Scala with `-Yliteral-types` compiler flag

### org/jetbrains/plugins/scala/annotator/element/ScMacroDefAnnotator.scala
macro.defs.must.have.explicit.return.type=Macro defs must have explicitly specified return types

### org/jetbrains/plugins/scala/annotator/element/ScMethodInvocationAnnotator.scala
annotator.error.unspecified.value.parameters.mkstring=Unspecified value parameters: {0}
annotator.error.cannot.resolve.overloaded.method=Cannot resolve overloaded method
annotator.error.too.many.arguments=Too many arguments
annotator.error.target.does.not.take.parameters={0} does not take parameters
missing.argument.list.for.method.with.explicit.list=Missing argument list {0} for method {1}
missing.argument.list.for.method=Missing argument list for method {0}
does.not.take.parameter.default.target=Application

### org/jetbrains/plugins/scala/annotator/element/ScNewTemplateDefinitionAnnotator.scala
illegal.instantiation={0} ''{1}'' is abstract; cannot be instantiated

### org/jetbrains/plugins/scala/annotator/element/ScNumericLiteralAnnotator.scala
octal.literals.removed=Octal literals syntax has been disabled since Scala 2.11
octal.literals.deprecated=Octal literals syntax has been deprecated in Scala 2.10
trailing.underscore.separator=Trailing underscore separator is not allowed
illegal.underscore.separator=Underscore separators require Scala 2.13
long.literal.is.out.of.range=Integer number is out of range even for type Long
integer.literal.is.out.of.range=Integer literal is out of range for type Int
lowercase.long.marker=Lower cased long literal marker

### org/jetbrains/plugins/scala/annotator/element/ScParameterAnnotator.scala
annotator.error.parameter.without.an.owner.name=Parameter without an owner: {0}
annotator.error.missing.type.annotation.for.parameter=Missing type annotation for parameter: {0}
missing.parameter.type.name=Missing parameter type: {0}
topic.parameters.may.not.be.call.by.name={0} parameters may not be call-by-name

### org/jetbrains/plugins/scala/annotator/element/ScParameterizedTypeElementAnnotator.scala
unspecified.type.parameters=Unspecified type parameters: {0}
too.many.type.arguments.for.typeparamowner=Too many type arguments for {0}
type.arg.does.not.conform.to.upper.bound=Type {0} does not conform to upper bound {1} of type parameter {2}
type.arg.does.not.conform.to.lower.bound=Type {0} does not conform to lower bound {1} of type parameter {2}
name.does.not.take.type.arguments={0} does not take type arguments
expected.type.constructor=Expected type constructor {0}
type.constructor.does.not.conform=Type constructor {0} does not conform to {1}
type.constructor.mismatch=Type constructor mismatch.

### org/jetbrains/plugins/scala/annotator/element/ScParametersAnnotator.scala
annotator.error.repeated.parameter.must.be.last=*-parameter must come last
annotator.error.repeated.or.default=Parameter section with *-parameter is not allowed to have default arguments

### org/jetbrains/plugins/scala/annotator/element/ScPatternAnnotator.scala
pattern.on.refinement.unchecked=a pattern match on a refinement type is unchecked
type.cannot.be.used.in.type.pattern=type {0} cannot be used in a type pattern or isInstanceOf test
scrutinee.incompatible.pattern.type=Scrutinee is incompatible with pattern type, found: {0}, required: {1}
pattern.type.incompatible.with.expected=Pattern type is incompatible with expected type, found: {0}, required: {1}
constructor.cannot.be.instantiated.to.expected.type=Constructor cannot be instantiated to expected type, found: {0}, required: {1}
fruitless.type.test=fruitless type test: a value of type {0} cannot also be a {1}
erasure.warning= (but still might match its erasure)
wrong.number.arguments.extractor=Wrong number of arguments for extractor, found: {0}, expected: {1}
wrong.number.arguments.extractor.unapplySeq=Wrong number of arguments for extractor, found: {0}, expected: {1} or more
stable.identifier.required=Stable identifier required but {0} found
better.monadic.for.invalid.pattern=Argument must have explicit type annotation

### org/jetbrains/plugins/scala/annotator/element/ScPatternArgumentListAnnotator.scala
vararg.pattern.must.be.last.pattern=_* can be used only for last argument

### org/jetbrains/plugins/scala/annotator/element/ScPatternTypeUnawareAnnotator.scala
vararg.pattern.with.colon.requires.scala3=':' syntax in vararg pattern requires Scala 3.0
vararg.pattern.with.at.deprecated.since.scala3='@' syntax in vararg pattern has been deprecated since Scala 3.0
vararg.short.pattern.with.at.deprecated.since.scala3=Short _* pattern syntax has been deprecated since Scala 3.0
family.name.replace.type.with.type.in.vararg.pattern=Replace ':' with '@' in vararg pattern
family.name.replace.with.scala3.vararg.pattern=Replace ':' syntax with Scala 3.0 vararg pattern
replace.with.type=Replace with ''{0}''
replace.with.scala3.wildcard.varargs=Replace with '_: _*'
family.name.replace.old.varags.with.scala3.varargs.pattern=Replace '_*' with '_: _*' in vararg pattern

### org/jetbrains/plugins/scala/annotator/element/ScReferenceAnnotator.scala
cannot.resolve=Cannot resolve symbol {0}
cannot.resolve.overloaded=Cannot resolve overloaded method ''{0}''
forward.reference.detected=Wrong forward reference
cannot.resolve.apply.method=Cannot resolve method {0}.apply
cannot.resolve.unapply.method=Cannot resolve method {0}.unapply
annotator.error.unspecified.type.parameters=Unspecified type parameters: {0}
annotator.error.does.not.take.type.parameters={0} does not take type parameters
annotator.error.too.many.type.arguments=Too many type arguments for {0}
annotator.error.too.many.arguments.method=Too many arguments for method {0}
annotator.error.sunspecified.value.parameters=Unspecified value parameters: {0}
annotator.error.name.has.malformed.definition=''{0}'' has malformed definition
annotator.error.missing.arguments.for.method=Missing arguments for method {0}
symbol.is.inaccessible.from.this.place=Symbol {0} is inaccessible from this place

### org/jetbrains/plugins/scala/annotator/element/ScReturnAnnotator.scala
return.expression.is.redundant=Returning {0} from a method with Unit result type
return.outside.method.definition=Return statement outside method definition

### org/jetbrains/plugins/scala/annotator/element/ScSelfInvocationAnnotator.scala
called.constructor.definition.must.precede=Called constructor's definition must precede calling constructor's definition
annotator.error.cannot.find.constructor.for.this.call=Cannot find constructor for this call

### org/jetbrains/plugins/scala/annotator/element/ScSimpleTypeElementAnnotator.scala
type.takes.type.parameters=Type {0} takes type parameters

### org/jetbrains/plugins/scala/annotator/element/ScStringLiteralAnnotator.scala
string.literal.is.too.long=String literal size exceeds compiler limit
string.literal.invalid.escape.character=Invalid escape character
string.literal.invalid.unicode.escape=Invalid unicode escape

### org/jetbrains/plugins/scala/annotator/element/ScSymbolLiteralAnnotator.scala
symbolliterals.are.deprecated=Symbol literals are deprecated in Scala 2.13. Use Symbol("{0}") instead.

### org/jetbrains/plugins/scala/annotator/element/ScTemplateDefinitionAnnotator.scala
illegal.inheritance.self.type=Illegal inheritance, self-type {0} does not conform to {1}
mixin.required={0} ''{1}'' needs to be mixin, since member ''{2}'' in ''{3}'' is marked ''abstract'' and ''override'', but no concrete implementation could be found in a base class
illegal.undefined.member=Only classes can have declared but undefined members
illegal.inheritance.from.final.kind=Illegal inheritance from final {0} ''{1}''
illegal.inheritance.from.value.class=Illegal inheritance from value class ''{0}''
illegal.inheritance.extends.enum=Extending enums is prohibited
illegal.inheritance.multiple={0} ''{1}'' inherited multiple times
illegal.mixin={0} ''{1}'' needs to be trait to be mixed in
member.implementation.required={0} ''{1}'' must either be declared abstract or implement abstract member ''{2}'' in ''{3}''
object.creation.impossible.since=Object creation impossible, since {0}
member.is.not.defined=member {0} in {1} is not defined

### org/jetbrains/plugins/scala/annotator/element/ScTraitAnnotator.scala
trait.parameter.require.scala3=Trait parameters require Scala 3.0

### org/jetbrains/plugins/scala/annotator/element/ScTypeBoundsOwnerAnnotator.scala
lower.bound.conform.to.upper=Lower bound doesn't conform to upper bound

### org/jetbrains/plugins/scala/annotator/element/ScTypedExpressionAnnotator.scala
cannot.upcast.type.to.other.type=Cannot upcast {0} to {1}

### org/jetbrains/plugins/scala/annotator/element/ScUnderscoreSectionAnnotator.scala
unbound.placeholder.parameter=Unbound placeholder parameter
local.variables.must.be.initialized=Local variables must be initialiazed
default.init.prohibited.literal.types=Default initialization prohibited for literal-typed vars

### org/jetbrains/plugins/scala/annotator/element/ScValueOrVariableAnnotator.scala
annotation.ascriptions.in.pattern.definitions.require.scala3=annotation ascriptions in pattern definitions require Scala 3.0

### org/jetbrains/plugins/scala/annotator/gutter/RecursiveCallLineMarkerProvider.scala
method.is.recursive=Method ''{0}'' is recursive
method.is.tail.recursive=Method ''{0}'' is tail recursive

### org/jetbrains/plugins/scala/annotator/gutter/ScalaGoToSuperActionHandler.scala
goto.super.member.chooser.title=Choose supermember
goto.super.class.chooser.title=Choose superclass
goto.super.class.or.member.chooser.title=Choose superclass / supermember

### org/jetbrains/plugins/scala/annotator/gutter/ScalaLineMarkerProvider.scala
companion.class=class
companion.object=object
companion.trait=trait
companion.enum=enum
go.to.companion=Go to companion {0}
go.to.implementation=Go to implementation
go.to.super.method=Go to super member
gutter.companion=Companion
gutter.implemented=Implemented member
gutter.implementing=Implementing member
gutter.overridden=Overridden member
gutter.overriding=Overriding member
gutter.recursion=Recursion type
gutter.sam=Implements SAM
has.companion=Has companion {0}
multiple.overriding.tooltip=Multiple overriding members
multiple.overriden.tooltip=Multiple overriden members
scala.line.markers=Scala line markers

### org/jetbrains/plugins/scala/annotator/gutter/ScalaMarkerType.scala
implements.member.prefix=Implements member
implements.member.from.prefix=Implements member from
implements.member.from.several.classes=Implements members from {0} classes
overrides.member.from.prefix=Overrides member from
overrides.member.from.several.classes=Overrides members from {0} classes
overrides.type.prefix=Overrides type
overrides.type.from.super.several.classes=Overrides type from {0} classes
navigation.title.super.members=Choose Super Member of {0}
navigation.findUsages.title.super.members=Super Members of {0}
navigation.title.super.types=Choose Super Type Member of {0}
navigation.findUsages.title.super.types=Super Type Member of {0}
trait.has.implementations=Is mixed into
trait.has.several.implementations=Is mixed into {0} classes
class.has.subclasses=Is extended by
class.has.several.subclasses=Is extended by {0} subclasses
has.implementations=Member has implementations
is.overridden.by=Member has overrides
navigation.title.inheritors.trait=<html>Choose Implementation of <b>{0}</b> ({1} classes found)</html>
navigation.findUsages.title.inheritors.trait=Implementations of {0}
navigation.title.inheritors.class=<html>Choose subclass of <b>{0}</b> ({1} classes found)</html>
navigation.findUsages.title.inheritors.class=Subclasses of {0}
navigation.title.implementing.member=<html>Choose Implementing Member of <b>{0}</b> ({1} members found)</html>
navigation.findUsages.title.implementing.member=Implementing Members of {0}
navigation.title.overriding.member=<html>Choose Overriding Member of <b>{0}</b> ({1} members found)</html>
navigation.findUsages.title.overriding.member=Overriding Members of {0}

### org/jetbrains/plugins/scala/annotator/hints/HintUI.scala
type.mismatch.dot=Type mismatch.

### org/jetbrains/plugins/scala/annotator/modifiers/ModifierChecker.scala
lazy.modifier.is.not.allowed.here='lazy' modifier allowed only with value definitions
lazy.modifier.is.not.allowed.with.param='lazy' modifier not allowed here, use call-by-name parameter instead
lazy.values.may.not.be.abstract=lazy values may not be abstract
final.modifier.not.with.declarations='final' modifier can't be used with incomplete members
final.modifier.not.with.trait='final' modifier not allowed with trait
final.modifier.is.redundant.with.final.parents='final' modifier is redundant for objects or final class members
final.modifier.is.not.allowed.here='final' modifier is not allowed here
access.modifier.is.not.allowed.here=''{0}'' modifier is not allowed here
abstract.modifier.redundant.fot.traits='abstract' modifier is redundant for traits
abstract.modifier.is.not.allowed='abstract' modifier allowed only for classes or for definitions with 'override' modifier
abstract.override.modifier.is.not.allowed='abstract override' modifier only allowed for members of traits
override.modifier.is.not.allowed.for.classes='override' modifier allowed only for type definitions members
override.modifier.is.not.allowed='override' modifier is not allowed here
sealed.modifier.is.not.allowed.here='sealed' modifier is not allowed here
illegal.modifiers.combination=Illegal modifiers combination: {0} and {1}
implicit.modifier.cannot.be.used.for.top.level.objects='implicit' modifier cannot be used for top-level objects
implicit.class.must.have.a.primary.constructor.with.one.argument=implicit class must have a primary constructor with exactly one argument in first parameter list
implicit.modifier.can.be.used.only.for='implicit' modifier can be used only for values, variables, methods and classes

### org/jetbrains/plugins/scala/annotator/package.scala
tree.mismatch.tooltip=\
  <html><body>{0}\
  <table>\
  <tr><td>Required:</td>{1}</tr>\
  <tr><td>Found:</td>{2}</tr>\
  </table>\
  </body></html>

### org/jetbrains/plugins/scala/annotator/quickfix/AddBreakoutQuickFix.scala
add.collection.breakout.argument=Add `collection.breakOut` argument
family.name.add.collection.breakout=Add `collection.breakOut`

### org/jetbrains/plugins/scala/annotator/quickfix/AddElementToMethodCallFix.scala
add.element=Add {0}

### org/jetbrains/plugins/scala/annotator/quickfix/AddReturnTypeFix.scala
add.return.type=Add return type

### org/jetbrains/plugins/scala/annotator/quickfix/ChangeTypeFix.scala
family.name.change.type=Change Type
change.type.to=Change type ''{0}'' to ''{1}''

### org/jetbrains/plugins/scala/annotator/quickfix/ConvertToExplicitSymbolQuickFix.scala
convert.to.explicit.symbol=Convert to Symbol("{0}")
convert.to.explicit.symbol.family=Convert to explicit Symbol

### org/jetbrains/plugins/scala/annotator/quickfix/EnableTypeMismatchHints.scala
family.name.enable.type.mismatch.hints=Enable type mismatch hints

### org/jetbrains/plugins/scala/annotator/quickfix/ImplementMethodsQuickFix.scala
implement.methods.fix=Implement methods

### org/jetbrains/plugins/scala/annotator/quickfix/ModifierQuickFix.scala
make.non.private.title=Make property non-private
add.modifier.fix.without.name=Add ''{0}'' modifier
remove.named.modifier.fix=Remove ''{0}'' modifier
make.protected.fix=Make property protected
make.public.fix=Make property public

### org/jetbrains/plugins/scala/annotator/quickfix/NumberLiteralQuickFix.scala
numeric.literal.family=Numeric literals
convert.to.hex.fix=Convert octal literal to hex
convert.to.long.fix=Convert to long literal
lowercase.long.marker.fix=Convert long literal marker to upper case

### org/jetbrains/plugins/scala/annotator/quickfix/PullUpQuickFix.scala
pull.method.to=Pull method ''{0}'' to...
pull.value.to=Pull value ''{0}'' to...
pull.variable.to=Pull variable ''{0}'' to...

### org/jetbrains/plugins/scala/annotator/quickfix/ReportHighlightingErrorQuickFix.scala
report.highlighting.error.fix=Report highlighting error...

### org/jetbrains/plugins/scala/annotator/quickfix/WrapInOptionQuickFix.scala
wrap.in.option.name=Wrap in Option
wrap.in.option.hint=Wrap expression in Option(...)?

### org/jetbrains/plugins/scala/annotator/template/CaseClassWithoutParamList.scala
family.name.add.empty.parentheses=Add empty parentheses
family.name.convert.to.object=Convert to object
case.classes.without.parameter.list.not.allowed=case classes without a parameter list are not allowed
case.classes.without.parameter.list.deprecated=case classes without a parameter list have been deprecated

### org/jetbrains/plugins/scala/annotator/template/ImplicitParametersAnnotator.scala
no.implicit.arguments.of.type=No implicit arguments of type: {0}

### org/jetbrains/plugins/scala/annotator/template/PrivateBeanProperty.scala
annotator.error.bean.property.should.not.be.private=Bean property should not be private

### org/jetbrains/plugins/scala/annotator/template/TraitHasImplicitBound.scala
traits.cannot.have.type.parameters.with.context.bounds=Traits cannot have type parameters with context bounds
traits.cannot.have.type.parameters.with.view.bounds=Traits cannot have type parameters with view bounds

### org/jetbrains/plugins/scala/autoImport/quickFix/ImportImplicitConversionFix.scala
import.with=Import ''{0}''
import.implicit.conversion=Import conversion ...

### org/jetbrains/plugins/scala/autoImport/quickFix/ImportImplicitInstanceFix.scala
import.implicit=Import implicit ...

### org/jetbrains/plugins/scala/autoImport/quickFix/ScalaAddImportAction.scala
import.class.chooser.title=Class to Import
import.package.chooser.title=Package to Import
import.something.chooser.title=Name to Import
import.conversion.chooser.title=Conversion to Import
import.implicit.chooser.title=Implicit to Import
add.import.action=Add import action
exclude.value.from.auto.import=Exclude ''{0}'' from auto-import

### org/jetbrains/plugins/scala/autoImport/quickFix/ScalaImportElementFix.scala
import.hint.text={0}? {1} Alt+Enter
import.multiple.choices=(multiple choices...)

### org/jetbrains/plugins/scala/autoImport/quickFix/ScalaImportGlobalMemberFix.scala
import.global.member=Import global member
import.as=Import as ''{0}''
import.with.prefix.ellipsis=Import with prefix ...
import.with.prefix=Import with prefix
import.something=Import ...

### org/jetbrains/plugins/scala/autoImport/quickFix/ScalaImportTypeFix.scala
import.class=Import class
import.package=Import package

### org/jetbrains/plugins/scala/build/BuildToolWindowReporter.scala
report.build.toolwindow.cancel=Cancel Build
report.build.toolwindow.running=running ...
report.build.toolwindow.failed=failed
report.build.toolwindow.canceled=canceled
report.build.toolwindow.items=items

### org/jetbrains/plugins/scala/build/ExternalSystemNotificationReporter.scala
report.build.task.canceled=task canceled

### org/jetbrains/plugins/scala/build/IndicatorReporter.scala
report.build.running=build running ...
report.build.completed=build completed
report.build.failed=build failed
report.failed.with.message=failed: {0}
report.canceled=canceled
report.warning.with.message=WARNING: {0}
report.error.with.message=ERROR: {0}
report.building=building ...

### org/jetbrains/plugins/scala/codeInsight/intention/AddBracesIntention.scala
family.name.add.braces=Add braces
add.braces.around.single.line.expression=Add braces around single line expression

### org/jetbrains/plugins/scala/codeInsight/intention/CreateCompanionObjectIntention.scala
create.companion.object.for.class=Create companion object for class
family.name.create.companion.object=Create companion object

### org/jetbrains/plugins/scala/codeInsight/intention/RemoveBracesIntention.scala
family.name.remove.braces=Remove braces

### org/jetbrains/plugins/scala/codeInsight/intention/collections/ComparingLengthIntention.scala
family.name.comparing.length=Replace with .sizeIs

### org/jetbrains/plugins/scala/codeInsight/intention/collections/FilterSetContainsIntention.scala
family.name.filter.set.contains=Remove redundant 'contains' in filter 

### org/jetbrains/plugins/scala/codeInsight/intention/collections/SomeToOptionIntention.scala
family.name.some.to.option=Some to Option

### org/jetbrains/plugins/scala/codeInsight/intention/comprehension/ConvertToCurlyBracesIntention.scala
family.name.convert.to.curly.braces=Convert to curly braces

### org/jetbrains/plugins/scala/codeInsight/intention/comprehension/ConvertToParenthesesIntention.scala
intention.for.comprehension.convert.to.parentheses=Convert to parentheses

### org/jetbrains/plugins/scala/codeInsight/intention/comprehension/DesugarForIntention.scala
desugar.for.comprehension=Desugar for comprehension
family.name.convert.to.desugared.expression=Convert to desugared expression

### org/jetbrains/plugins/scala/codeInsight/intention/expression/ConvertFromInfixExpressionIntention.scala
family.name.convert.from.infix.expression=Convert from infix expression

### org/jetbrains/plugins/scala/codeInsight/intention/expression/ConvertParameterToUnderscoreIntention.scala
family.name.convert.parameter.to.underscore.section=Convert parameter to underscore section

### org/jetbrains/plugins/scala/codeInsight/intention/expression/ConvertToInfixExpressionIntention.scala
family.name.convert.to.infix.expression=Convert to infix expression

### org/jetbrains/plugins/scala/codeInsight/intention/expression/ConvertUnderscoreToParameterIntention.scala
family.name.convert.underscore.section.to.parameter=Convert underscore section to parameter

### org/jetbrains/plugins/scala/codeInsight/intention/expression/MakeImplicitConversionExplicit.scala
family.name.make.implicit.conversion.explicit=Make implicit conversion explicit

### org/jetbrains/plugins/scala/codeInsight/intention/expression/RemoveApplyIntention.scala
family.name.remove.unnecessary.apply=Remove unnecessary apply

### org/jetbrains/plugins/scala/codeInsight/intention/expression/RemoveUnnecessaryParenthesesIntention.scala
remove.unnecessary.parentheses=Remove unnecessary parentheses

### org/jetbrains/plugins/scala/codeInsight/intention/expression/ReplaceTypeCheckWithMatchIntention.scala
family.name.replace.type.check.with.pattern.matching=Replace type check with pattern matching

### org/jetbrains/plugins/scala/codeInsight/intention/imports/ImportAdditionalIdentifiersIntention.scala
family.name.import.additional.identifiers=Import additional identifiers
import.additional.identifiers.from.qualifier=Import additional identifiers from qualifier

### org/jetbrains/plugins/scala/codeInsight/intention/imports/ImportAllMembersIntention.scala
family.name.import.all.members=Import all members
import.all.members.of.reference=Import all members of {0}

### org/jetbrains/plugins/scala/codeInsight/intention/imports/ImportStableMemberIntention.scala
family.name.import.member.with.stable.path=Import member with stable path
import.stable.member=Import {0}

### org/jetbrains/plugins/scala/codeInsight/intention/matcher/ConvertToTypedPatternIntention.scala
convert.to.typed.pattern=Convert to typed pattern

### org/jetbrains/plugins/scala/codeInsight/intention/matcher/ExpandPatternIntention.scala
family.name.expand.to.constructor.pattern=Expand to Constructor pattern
expand.to.new.pattern=Expand to: {0}

### org/jetbrains/plugins/scala/codeInsight/intention/types/AddUnitTypeAnnotationIntention.scala
intention.add.explicit.unit.type.annotation=Add explicit Unit Type Annotation
intention.type.annotation.function.add.text=Add type annotation to function definition

### org/jetbrains/plugins/scala/codeInsight/intention/types/AdjustTypesIntention.scala
family.name.adjust.types=Adjust types

### org/jetbrains/plugins/scala/codeInsight/intention/types/ConvertFromInfixIntention.scala
family.name.use.prefix.type.syntax=Use Prefix Type Syntax

### org/jetbrains/plugins/scala/codeInsight/intention/types/ConvertImplicitBoundsToImplicitParameter.scala
family.name.convert.implicit.bounds=Convert Implicit Bounds
convert.view.and.context.bounds.to.implicit.parameters=Convert view and context bounds to implicit parameters

### org/jetbrains/plugins/scala/codeInsight/intention/types/ConvertJavaToScalaCollectionIntention.scala
convert.java.to.scala.collection.hint=Convert to Scala collection using asScala?
convert.java.to.scala.collection.name=Convert to Scala collection

### org/jetbrains/plugins/scala/codeInsight/intention/types/ConvertScalaToJavaCollectionIntention.scala
convert.scala.to.java.collection.hint=Convert to Java collection using asJava?
convert.scala.to.java.collection.name=Convert to Java collection

### org/jetbrains/plugins/scala/codeInsight/intention/types/ConvertToInfixIntention.scala
family.name.use.infix.type.syntax=Use Infix Type Syntax

### org/jetbrains/plugins/scala/codeInsight/intention/types/MakeTypeMoreSpecificIntention.scala
make.type.more.specific.fun=Make return type more specific
make.type.more.specific=Make declared type more specific

### org/jetbrains/plugins/scala/codeInsight/intention/types/RegenerateTypeAnnotation.scala
intention.type.annotation.regen.family=Regenerate Type Annotation
intention.type.annotation.function.regenerate.text=Regenerate type annotation for function definition
intention.type.annotation.value.regenerate.text=Regenerate type annotation for value definition
intention.type.annotation.variable.regenerate.text=Regenerate type annotation for variable definition

### org/jetbrains/plugins/scala/codeInsight/intention/types/ToggleTypeAnnotation.scala
intention.type.annotation.toggle.family=Toggle Type Annotation
intention.type.annotation.function.remove.text=Remove type annotation from function definition
intention.type.annotation.value.add.text=Add type annotation to value definition
intention.type.annotation.value.remove.text=Remove type annotation from value definition
intention.type.annotation.variable.add.text=Add type annotation to variable definition
intention.type.annotation.variable.remove.text=Remove type annotation from variable definition
intention.type.annotation.pattern.add.text=Add type annotation to pattern definition
intention.type.annotation.pattern.remove.text=Remove type annotation from pattern definition
intention.type.annotation.parameter.add.text=Add type annotation to parameter
intention.type.annotation.parameter.remove.text=Remove type annotation from parameter
intention.type.annotation.underscore.add.text=Add type annotation to underscore parameter
intention.type.annotation.underscore.remove.text=Remove type annotation from underscore parameter

### org/jetbrains/plugins/scala/codeInsight/unwrap/ScalaCaseClauseRemover.scala
remove.case.clause=Remove case clause

### org/jetbrains/plugins/scala/codeInsight/unwrap/ScalaCatchOrFinallyRemover.scala
remove.finally=Remove finally block
remove.catch=Remove catch block

### org/jetbrains/plugins/scala/codeInsight/unwrap/ScalaInterpolatedStringUnwrapper.scala
unwrap.interpolated.string.injection=Unwrap interpolated string injection

### org/jetbrains/plugins/scala/codeInsight/unwrap/ScalaMatchUnwrapper.scala
unwrap.case.clause=Unwrap case clause

### org/jetbrains/plugins/scala/codeInsight/unwrap/ScalaTryOrFinallyUnwrapper.scala
unwrap.finally=Unwrap finally

### org/jetbrains/plugins/scala/codeInsight/unwrap/ScalaTryWithFinallyUnwrapper.scala
unwrap.try.with.finally=Unwrap try / finally

### org/jetbrains/plugins/scala/codeInspection/caseClassParamInspection/CaseClassParamInspection.scala
val.on.case.class.param.redundant='val' modifier is redundant for parameter of case class primary constructor

### org/jetbrains/plugins/scala/codeInspection/caseClassParamInspection/RemoveValQuickFix.scala
remove.val=Remove 'val'

### org/jetbrains/plugins/scala/codeInspection/catchAll/ReplaceDangerousCatchAllQuickFix.scala
specify.type.of.exception=Specify type of exception

### org/jetbrains/plugins/scala/codeInspection/forwardReferenceInspection/ForwardReferenceInspection.scala
suspicicious.forward.reference.template.body=Suspicious forward reference in class

### org/jetbrains/plugins/scala/codeInspection/imports/RemoveBracesForSingleImportQuickFix.scala
remove.braces.from.import=Remove braces from import statement

### org/jetbrains/plugins/scala/codeInspection/relativeImports/RelativeImportInspection.scala
make.import.fully.qualified=Make import fully qualified

### org/jetbrains/plugins/scala/codeInspection/scaladoc/ScalaDocInlinedTagInspection.scala
delete.inlined.tag=Delete Inlined Tag
replace.with.wiki.syntax=Replace inlined tag with monospace wiki syntax

### org/jetbrains/plugins/scala/codeInspection/scaladoc/ScalaDocUnbalancedHeaderInspection.scala
move.text.after.header.to.new.line=Move text after header closing to new line
balance.header=Balance Header

### org/jetbrains/plugins/scala/codeInspection/scaladoc/ScalaDocUnclosedTagWithoutParserInspection.scala
replace.tag.with.esc.seq=Replace tag with escape sequence

### org/jetbrains/plugins/scala/codeInspection/scaladoc/ScalaDocUnknownParameterInspection.scala
delete.duplicating.param=Delete duplicating parameter
delete.tag=Delete tag

### org/jetbrains/plugins/scala/codeInspection/scaladoc/ScalaDocUnknownTagInspection.scala
delete.unknown.tag=Delete Unknown Tag

### org/jetbrains/plugins/scala/codeInspection/syntacticSimplification/FunctionTupleSyntacticSugarInspection.scala
replace.tuple.type=Replace TupleN[A1, A1, ...,  AN] with (A1, A1, ...,  AN)
replace.fun.type=Replace FunctionN[A1, A1, ...,  AN, R] with (A1, A1, ...,  AN) => R

### org/jetbrains/plugins/scala/codeInspection/syntacticSimplification/RedundantNewCaseClassInspection.scala
new.on.case.class.instantiation.redundant=remove 'new' modifier

### org/jetbrains/plugins/scala/codeInspection/syntacticSimplification/RemoveRedundantReturnInspection.scala
remove.return.keyword=Remove return keyword

### org/jetbrains/plugins/scala/codeInspection/xml/ScalaXmlUnmatchedTagInspection.scala
xml.no.opening.tag=No Opening Tag
xml.no.closing.tag=No Closing Tag
xml.delete.unmatched.tag=Delete Unmatched Tag
xml.rename.opening.tag=Rename Opening Tag
xml.rename.closing.tag=Rename Closing Tag

### org/jetbrains/plugins/scala/compilationCharts/ui/ActionPanel.scala
compilation.charts.reset.zoom.action.text=Reset vertical zoom
compilation.charts.reset.zoom.action.description=Reset vertical zoom for compilation charts
compilation.charts.zoom.out.action.text=Vertical zoom out
compilation.charts.zoom.out.action.description=Vertical zoom out for compilation charts
compilation.charts.zoom.in.action.text=Vertical zoom in
compilation.charts.zoom.in.action.description=Vertical zoom in for compilation charts

### org/jetbrains/plugins/scala/compilationCharts/ui/CompilationChartsBuildToolWindowNodeFactory.scala
compilation.charts.title=Chart

### org/jetbrains/plugins/scala/compiler/CompileServerLauncher.scala
cannot.start.scala.compile.server=Cannot start Scala compile server
jdk.for.compiler.process.not.found=JDK for compiler process not found: {0}
required.file.not.found.paths=Required file(s) not found: {0}
can.t.find.default.jdk=Can't find default jdk
cant.find.jdk=Can''t find jdk: {0}

### org/jetbrains/plugins/scala/compiler/CompileServerManager.scala
scala.compile.server.title=Scala Compile Server
action.run=&Run
start.compile.server=Start compile server
action.stop=&Stop
shutdown.compile.server=Shutdown compile server
action.configure=&Configure...
configure.compile.server=Configure compile server

### org/jetbrains/plugins/scala/compiler/EnsureModulesHaveDifferentProdAndTestOutputsTask.scala
shared.compile.output.paths.in.scala.modules=Shared compile output paths in Scala module(s)
production.and.test.output.paths.are.shared.in=Production and test output paths are shared in: {0}
split.output.paths.automatically=Split output path(s) automatically
cancel.compilation=Cancel compilation

### org/jetbrains/plugins/scala/compiler/RemoteServerRunner.scala
cannot.connect.to.compile.server=Cannot connect to compile server at {0}:{1}

### org/jetbrains/plugins/scala/compiler/ScalaCompileServerForm.form
#ScalaCompileServer UI
jvm.options=VM &options:
jvm.maximum.heap.size.mb=Maximum &heap size, MB:
jdk=&JDK:
minutes=minutes
compile.server.jvm.command.line.parameters=Compile server JVM command line parameters
compile.server.shutdown.if.idle.for=Stop if idle for
compile.server.use.for.scala=Use compile server
compile.server.parallelism=threads
compile.server.parallel.compilation=Compile independent modules in parallel, in up to

### org/jetbrains/plugins/scala/compiler/ScalaCompileServerForm.java
compile.server.new.project.restart=To change the process working directory, the server has to be restarted on each project change.
compile.server.use.project.home=Start process in &project directory
compile.server.description=The JDK is used to instantiate the compile server and to invoke \nan in-process Java compiler (when JDK and module SDK match).

### org/jetbrains/plugins/scala/compiler/package.scala
unexpected.sdk.type.for.sdk=Unexpected sdk type: ''{0}'' for sdk {1}

### org/jetbrains/plugins/scala/components/PluginVersionVerifier.scala
incompatible.plugin.detected=Incompatible plugin detected

### org/jetbrains/plugins/scala/components/Scala3Disclaimer.scala
scala.3.support.is.experimental=Scala 3 support is work in progress.<br>Consider using nightly builds. <a href=''{0}''>Learn more</a>
configure.updates=Configure updates...
scala.3.support.is.incompatible=Dotty version: {0}, supported version: {1}
adjust.dotty.version=Use Dotty {0}

### org/jetbrains/plugins/scala/components/ScalaPluginUpdater.scala
scala.plugin.update.failed=Scala plugin update failed
idea.is.outdated.please.update=Your IDEA is outdated to use with Scala plugin {0} branch.<br/>Please update IDEA to at least {1} to use latest Scala plugin.
please.select.scala.plugin.update.channel=Please select Scala plugin update channel:
channel.stable.releases=Stable Releases
channel.early.access.program=Early Access Program
channel.nightly.builds=Nightly Builds
switch.idea.to.eap.question=Your IDEA is outdated to use with {0} branch.<br/>Would you like to switch IDEA channel to EAP?
switch.yes=Yes
switch.not.now=Not now
switch.ignore.this.update=Ignore this update

### org/jetbrains/plugins/scala/components/TypeAwareWidgetFactory.scala
scala.type.aware.highlighting.indicator=Scala Type Aware Highlighting Indicator
type.aware.highlighting.title=Scala type-aware highlighting
click.or.press.shortcut.to.change=(click or press {0} to change)
click.to.change=(click to change)
enabled.word=enabled
disabled.word=disabled

### org/jetbrains/plugins/scala/components/libextensions/ExtensionDownloader.scala
downloading.url=Downloading {0}

### org/jetbrains/plugins/scala/components/libextensions/LibraryExtensionsManager.scala
title.searching.for.library.extensions=Searching for library extensions

### org/jetbrains/plugins/scala/components/libextensions/ui/LibExtensionsSettingsPanelWrapper.scala
select.library.from.the.list.above=Select library from the list above
idea.will.try.to.search.for.extra.support.for.particular.libraries=IDEA will try to search for extra support for particular libraries in your project
title.failed.to.load.extension.jar=Failed to load extension JAR
no.known.extension.libraries=No known extension libraries
known.extension.libraries=Known extension libraries
extensions.in.selected.library=Extensions in selected library
enable.loading.external.extensions=Enable loading external extensions
how.to.add.custom.macro.support.help.link.title=How to add custom scala macros support

### org/jetbrains/plugins/scala/components/libextensions/ui/PopupHelper.scala
title.extensions.available=Extensions available
additional.support.has.been.found.popup=\
  <p>Additional support has been found for some of your libraries.</p>\
  <p>Do you want to enable it? <a href="Yes">Yes</a> / <a href="No">No</a></p>

### org/jetbrains/plugins/scala/console/actions/RunConsoleAction.scala
scala.console.actions.scala.repl=Scala REPL
scalarepl.menu.action.text=Scala REPL...
scalarepl.menu.action.description=Run Scala REPL

### org/jetbrains/plugins/scala/console/actions/ScalaConsoleCleanAction.scala
clean.scala.repl.content.menu.action.text=Clean Scala REPL Content
clean.scala.repl.content.menu.action.description=Clean Scala REPL Content

### org/jetbrains/plugins/scala/console/actions/ScalaConsoleExecuteAction.scala
execute.scala.repl.statement.menu.action.text=Execute Scala REPL Statement
execute.scala.repl.statement.menu.action.description=Execute Scala REPL Statement

### org/jetbrains/plugins/scala/console/actions/ScalaConsoleNewLineAction.scala
scalaconsole.new.line.in.repl=New line in REPL

### org/jetbrains/plugins/scala/console/actions/SendSelectionToConsoleAction.scala
send.selection.to.scala.repl.menu.action.text=Send Selection To Scala REPL
send.selection.to.scala.repl.menu.action.description=Send Selection To Scala REPL

### org/jetbrains/plugins/scala/console/configuration/ScalaConsoleConfigurationType.scala
scala.console.config.display.name=Scala REPL
scala.console.config.scala.repl.run.configurations=Scala REPL run configurations

### org/jetbrains/plugins/scala/console/configuration/ScalaConsoleRunConfiguration.scala
scala.console.config.module.is.not.specified=Module is not specified

### org/jetbrains/plugins/scala/console/configuration/ScalaConsoleRunConfigurationForm.form
scala.console.config.working.directory=Working directory:
scala.console.config.use.classpath.and.sdk.of.module=Use classpath and SDK of module:

### org/jetbrains/plugins/scala/console/configuration/ScalaConsoleRunConfigurationForm.java
scala.console.config.vm.options=VM options
scala.console.config.console.arguments=Console arguments
scala.console.config.test.run.config.choose.working.directory=Choose Working Directory

### org/jetbrains/plugins/scala/console/configuration/ScalaSdkJLineFixer.scala
scala.console.configure.scala.sdk.classpath=&Configure Scala SDK classpath
#parameters:
# 0 - subsystem name (e.g. Console)
# 1 - jline jar name
subsystem.requires.jline={0} requires {1}\nPlease add it to the compiler classpath

### org/jetbrains/plugins/scala/debugger/ScalaFrameExtraVariablesProvider.scala
debug.process.is.detached=Debug process is detached.

### org/jetbrains/plugins/scala/debugger/breakpoints/ScalaLineBreakpointType.scala
line.breakpoints.tab.title=Scala Line Breakpoints
breakpoint.location.constructor.of=constructor of {0}
breakpoint.location.early.definitions.of=early definitions of {0}
breakpoint.location.line.in.containing.block=line in containing block
breakpoint.location.line.in.function=line in function {0}
breakpoint.location.line.in.containing.file=line in containing file

### org/jetbrains/plugins/scala/debugger/evaluation/ScalaEvaluatorBuilder.scala
non-scala.code.fragment=Non-scala code fragment in scala evaluator builder
evaluation.of.object.needs.compilation=Evaluation of object needs compilation
evaluation.of.class.needs.compilation=Evaluation of class needs compilation
evaluation.of.trait.needs.compilation=Evaluation of trait needs compilation
evaluation.of.anonymous.class.needs.compilation=Evaluation of anonymous class needs compilation
evaluation.of.type.alias.needs.compilation=Evaluation of type alias needs compilation
evaluation.of.function.definition.needs.compilation=Evaluation of function definition needs compilation
evaluation.of.variable.declaration.needs.compilation=Evaluation of variable declaration needs compilation
evaluation.of.lazy.val.definition.needs.compilation=Evaluation of lazy val definition needs compilation
evaluation.of.anonymous.function.needs.compilation=Evaluation of anonymous function needs compilation
evaluation.of.for.expression.needs.compilation=Evaluation of for expression needs compilation
evaluation.of.try.statement.needs.compilation=Evaluation of try statement needs compilation
evaluation.of.return.statement.needs.compilation=Evaluation of return statement needs compilation
evaluation.of.match.statement.needs.compilation=Evaluation of match statement needs compilation
evaluation.of.throw.statement.needs.compilation=Evaluation of throw statement needs compilation
evaluation.of.xml.expression.needs.compilation=Evaluation of xml expression needs compilation
evaluation.of.interpolated.string.needs.compilation=Evaluation of interpolated string needs compilation
cannot.find.by.name.parameter.with.such.name=Cannot find by-name parameter with such name: {0}
evaluation.of.expression.is.not.supported=Evaluation of expression is not supported: {0}
evaluation.of.element.is.not.supported=Evaluation of element is not supported: {0}

### org/jetbrains/plugins/scala/debugger/evaluation/ScalaEvaluatorBuilderUtil.scala
cannot.evaluate.imported.reference=Cannot evaluate imported reference
cannot.evaluate.local.method=Cannot evaluate local method
cannot.evaluate.parameter=Cannot evaluate parameter {0}
cannot.evaluate.method=Cannot evaluate method {0}
cannot.evaluate.local.object=Cannot evaluate local object {0}
cannot.evaluate.local.variable=Cannot evaluate local variable {0}
wrong.number.of.arguments=Wrong number of arguments for method {0}
array.instance.is.not.found=Cannot evaluate method {0}: array instance is not found
array.method.not.supported=Array method not supported
cannot.find.implicit.parameters=Cannot find implicit parameters to pass
implicit.parameters.from.dependent.objects=Implicit parameters from dependent objects are not supported
implicit.conversions.from.dependent.objects=Implicit conversions from dependent objects are not supported
method.with.by-name.parameters=Cannot evaluate methods with by-name parameters
wrong.number.of.expressions=Cannot evaluate arguments: wrong number of matched expressions
tupling.not.supported=Tupling is not supported. Use tuple expression.
not.used.from.for.statement=Cannot evaluate variable {0} from a for-statement because it was not used in the body
cannot.find.pattern=Cannot find pattern of case clause
cannot.find.expression.of.match=Cannot find expression of match statement
invalid.case.clause=Invalid case clause
assignent.without.expression=Cannot evaluate assign statement without expression
unapply.without.arguments=Cannot extract value from unapply without arguments
pattern.doesnot.resolves.to.unapply=Pattern reference {0} does not resolve to unapply or unapplySeq
pattern.alternatives.cannot.bind.vars=Pattern alternatives cannot bind variables
xml.patterns.not.supported=Xml patterns are not supported
kind.of.patterns.not.supported=This kind of patterns is not supported: {0}
anon.classes.not.supported=Anonymous classes are not supported
new.expression.without.class.reference=Cannot evaluate new expression without class reference
new.expression.without.constructor.call=Cannot evaluate expression without constructor call
new.expression.without.template.parents=Cannot evaluate expression without template parents
could.not.resolve.constructor=Could not resolve constructor
if.statement.without.condition=Cannot evaluate if statement without condition
if.statement.without.if.branch=Cannot evaluate if statement without if branch
while.statement.without.condition=Cannot evaluate while statement without condition
while.statement.without.body=Cannot evaluate while statement without body
do.statement.without.condition=Cannot evaluate do statement without condition
do.statement.without.body=Cannot evaluate do statement without body
method.call.implicitly.converted.qualifier=Cannot evaluate method call with implicitly converted qualifier: {0}
synchronized.statement.is.not.supported=synchronized statement is not supported
cannot.evaluate.synthetic.method=Cannot evaluate synthetic method: {0}
by.name.parameter.expected=By-name parameter expected
update.method.is.not.supported=Update method is not supported
variable.definition.needs.right.hand.side=Variable definition needs right hand side: {0}
value.definition.needs.right.hand.side=Value definition needs right hand side: {0}

### org/jetbrains/plugins/scala/debugger/evaluation/ScalaEvaluatorCompileHelper.scala
could.not.compile=Could not compile:\n{0}
compilation.failed=Compilation failed

### org/jetbrains/plugins/scala/debugger/evaluation/evaluator/ScalaBoxingEvaluator.scala
cannot.perform.boxing.conversion.for.result=Cannot perform boxing conversion for {0}

### org/jetbrains/plugins/scala/debugger/evaluation/evaluator/ScalaCompilingEvaluator.scala
could.not.compile.generated.class=Could not compile generated class
error.during.generated.code.invocation=Error during generated code invocation:\n {0}
error.creating.evaluation.class.loader=Error creating evaluation class loader:\n {0}
error.during.classes.definition=Error during classes definition:\n {0}
module.for.compilation.is.not.found=Module for compilation is not found
could.not.evaluate.due.to.a.change.in.a.source.file=Could not evaluate due to a change in a source file
could.not.compile.local.class.in.this.context=Could not compile local class in this context

### org/jetbrains/plugins/scala/debugger/evaluation/evaluator/ScalaDoStmtEvaluator.scala
condition.has.wrong.type=condition has wrong type

### org/jetbrains/plugins/scala/debugger/evaluation/evaluator/ScalaLiteralEvaluator.scala
unknown.type.of.literal=unknown type of literal
literal.has.null.value=Literal {0} has null value

### org/jetbrains/plugins/scala/debugger/evaluation/evaluator/ScalaMethodEvaluator.scala
could.not.find.appropriate.constructor.for.name=Couldn''t find appropriate constructor for {0}
cannot.invoke.abstract.interface.method.name=Cannot invoke abstract interface method {0}
method.methodname.cannot.be.invoked.on.array=Method {0} cannot be invoked on array

### org/jetbrains/plugins/scala/debugger/evaluation/evaluator/ScalaThisEvaluator.scala
outer.this.not.available=Outer `this` is not available

### org/jetbrains/plugins/scala/debugger/filters/ScalaDebuggerSettingsConfigurable.form
friendly.collection.debug.start.index=Collection start index
friendly.collection.debug.end.index=Collection end index
friendly.collection.display.enabled=Friendly display of Scala collections in debugger
friendly.collection.do.not.display.streams=Do not expand Streams and Views
dont.show.runtime.refs=Do not show runtime refs in debugger
show.variables.from.outer.scopes.in.variables.view=Show variables from outer scopes in variables view

### org/jetbrains/plugins/scala/debugger/filters/ScalaDebuggerSettingsConfigurable.java
scala.debug.caption=Scala

### org/jetbrains/plugins/scala/debugger/filters/ScalaSteppingConfigurable.form
scala.debug.disable.specific.methods=Do not step &into specific Scala classes

### org/jetbrains/plugins/scala/debugger/ui/NonStrictCollectionsRenderer.scala
scala.streams.as.collections=Scala streams as collections

### org/jetbrains/plugins/scala/debugger/ui/RuntimeRefRenderer.scala
scala.runtime.references.renderer=Scala runtime references renderer

### org/jetbrains/plugins/scala/debugger/ui/ScalaCollectionRenderer.scala
scala.collection=Scala collection
cannot.evaluate.expression=Cannot evaluate expression
value.is.not.an.integer={0} is not an integer
value.is.not.a.boolean={0} is not a boolean

### org/jetbrains/plugins/scala/editor/autoimport/ScalaAutoImportOptionsProviderForm.scala
auto.import.insert.imports.on.paste=Insert imports on paste:
auto.import.show.import.popup.for=Show import popup for:
auto.import.add.unambiguous.imports.on.the.fly.for=Add unambiguous imports on the fly for:
auto.import.optimize.imports.on.the.fly=Optimize imports on the fly
auto.import.show.popup.classes=Classes
auto.import.show.popup.methods=Static members
auto.import.show.popup.conversions=Implicit conversions
auto.import.show.popup.implicits=Implicit definitions
options.scala.display.name=Scala
auto.import.find.more.options.in=Find more options in 
auto.import.code.style.link=Code Style

### org/jetbrains/plugins/scala/externalHighlighters/CompilerEventGeneratingClient.scala
highlighting.compilation.progress=Highlighting: {0}

### org/jetbrains/plugins/scala/externalHighlighters/CompilerHighlightingService.scala
highlighting.compilation=Error/Warning highlighting

### org/jetbrains/plugins/scala/findUsages/compilerReferences/ScalaCompilerReferenceService.scala
open.compiler.index.reader=Open compiler index reader
index.invalidation.callback=Index invalidation callback

### org/jetbrains/plugins/scala/findUsages/compilerReferences/SearchTargetExtractors.scala
bytecode.indices.target.sam.type=SAM type
bytecode.indices.target.unapply.method=apply/unapply method
bytecode.indices.target.for.comprehension.method=for-comprehension method
bytecode.indices.target.implicit.definition=implicit definition

### org/jetbrains/plugins/scala/findUsages/compilerReferences/compilation/JpsCompilationWatcher.scala
malformed.message.from.builder=Malformed messageText from builder: {0}

### org/jetbrains/plugins/scala/findUsages/compilerReferences/compilation/SbtCompilationWatcher.scala
failed.to.parse.offline.compilation.analysis.files=Failed to parse offline compilation analysis files.
sbt.module.added=sbt module added.
sbt.connection.failure=sbt compilation supervisor: connection failure.
failed.to.parse.compilation.info.file=Failed to parse compilation info file {0}
error.while.reading.sbt.compilation.info=An error occured while trying to read sbt compilation info files.

### org/jetbrains/plugins/scala/findUsages/compilerReferences/indices/CompilerReferenceIndexer.scala
bytecode.indices.indexing=Indexing classfiles ...
title.initializing.compiler.indices.writer=Initializing compiler indices writer
title.closing.compiler.indices.writer=Closing compiler indices writer
title.invalidating.compiler.indices=Invalidating compiler indices

### org/jetbrains/plugins/scala/findUsages/compilerReferences/indices/CompilerReferenceIndexerScheduler.scala
bytecode.indices.progress.title=Indexing recompiled classfiles ...

### org/jetbrains/plugins/scala/findUsages/compilerReferences/search/CompilerIndicesReferencesSearcher.scala
bytecode.indices.unavailable=Find Usages via bytecode indices is unavailable during compilation.
bytecode.indices.in.progress=Indexing In Progress

### org/jetbrains/plugins/scala/findUsages/compilerReferences/search/CompilerIndicesSearcher.scala
bytecode.indices.find.usages=Find Usages
bytecode.indices.invalidated.title=Usages Invalidated
bytecode.indices.invalidated.message=Some usages in the following files may have been invalidated, due to external changes: {0}.

### org/jetbrains/plugins/scala/findUsages/compilerReferences/search/ImplicitUsagesSearchDialogs.scala
bytecode.indices.find.usages.with.title=Find Usages ({0})
bytecode.indices.settings.navigate=Navigate to bytecode indices settings
bytecode.indices.enable.indexing=Enable Bytecode Indexing
bytecode.indices.enable=Enable
bytecode.indices.enable.and.restart=Enable and restart
bytecode.indices.precompile=Pre-compile modules in use scope before searching
bytecode.indices.bytecode=bytecode
bytecode.indices.settings=Settings | Bytecode Indices
bytecode.indices.required=This search relies on the
bytecode.indices.outdated=, which is not up-to-date.
bytecode.indices.incomplete=Results may be incomplete without a compilation.
bytecode.indices.must.be.enabled.1=Searching for {0} usages requires bytecode indices to be enabled.
bytecode.indices.must.be.enabled.2=Do you want to enable bytecode indexing (takes effect after IDEA restart)?

### org/jetbrains/plugins/scala/findUsages/compilerReferences/settings/CompilerIndicesConfigurable.scala
bytecode.indices=Bytecode Indices
bytecode.indices.restart.title=Bytecode Indices Settings Update
bytecode.indices.restart.message=Restart IDEA to activate changes in bytecode indices settings?
bytecode.indices.shutdown.message=Shutdown IDEA to activate changes in bytecode indices settings?

### org/jetbrains/plugins/scala/findUsages/compilerReferences/settings/CompilerIndicesSettingsForm.form
scala.compiler.indices.settings.enable.cb=&Index .class files
scala.compiler.indices.settings.invalidate.button=&Delete indices
scala.compiler.indices.sbt.automatic=&Automatic (requires sbt shell)
scala.compiler.indices.sbt.manual=&Manual
#Bytecode indices settings
apply.unapply.methods=apply / unapply methods
for.comprehension.methods=For-comprehension methods (map, withFilter, flatMap, foreach)
add.line.to.build.sbt=Add the following line to build.sbt:
add.line.to.plugins.sbt=Add the following line to project/plugins.sbt:
implicit.definitions=Implicit definitions
port.number=Port number:
sam.types=SAM types
sbt.compilation.listener=sbt compilation listener configuration (application-wide)
use.indices.to.search=Use indices to search for usages of:

### org/jetbrains/plugins/scala/findUsages/compilerReferences/settings/CompilerIndicesSettingsForm.java
are.you.sure.you.want.to.delete.the.bytecode.indices=Are you sure you want to delete the bytecode indices?
delete.bytecode.indices=Delete Bytecode Indices

### org/jetbrains/plugins/scala/findUsages/factory/ScalaFindUsagesHandlerFactory.scala
find.usages.member.has.supers=Member {0} overrides/implements some base member.\n\
  Do you want to find usages for the base member?
title.warning=Warning

### org/jetbrains/plugins/scala/findUsages/factory/ScalaTypeDefinitionUsagesDialog.scala
find.what.members.usages.checkbox=Usages of &members
find.what.implementing.type.definitions.checkbox=Implementing type &definitions
find.what.companion.module.checkbox=Usages of &companion module
find.what.new.instances.usages=&Instance creation only

### org/jetbrains/plugins/scala/highlighter/ScalaColorSchemeAnnotator.scala
scala.mutable.collection=Mutable Collection
scala.immutable.collection=Immutable Collection
java.collection=Java Collection

### org/jetbrains/plugins/scala/lang/completion/ScalaCompletionUtil.scala
wrong.top.statment.declaration=Wrong top statement declaration

### org/jetbrains/plugins/scala/lang/completion/ScalaGlobalMembersCompletionContributor.scala
to.import.method.statically.press.hotkey=To import a method statically, press {0}

### org/jetbrains/plugins/scala/lang/completion/lookups/ScalaImportStaticLookupActionProvider.scala
action.import.member=Import member

### org/jetbrains/plugins/scala/lang/findUsages/ScalaFindUsagesProvider.scala
method.of.containingclass={0} of {1}
descritive.name.anonymous=anonymous

### org/jetbrains/plugins/scala/lang/findUsages/ScalaUsageTypeProvider.scala
usage.extractor=Extractor
usage.typed.pattern=Typed Pattern
usage.typed.statement=Typed Statement
usage.method.apply=Method `apply`
usage.this.reference=This Reference
usage.access.modifier=Access Modifier
usage.package.clause=Package Clause
usage.function.expression=Function expression
usage.named.parameter=Named parameter
usage.interpolated.string.prefix=Interpolated string prefix
usage.parameter.in.pattern=Parameter in pattern
usage.self.type=Self type
usage.type.bound=Type bound
usage.type.alias=Type alias
usage.secondary.constructor=Secondary constructor
usage.implicit.conversion.parameter=Implicit Conversion/Parameter
usage.unresolved.implicit.conversion.parameter=Unresolved Implicit Conversion/Parameter
usage.sam.interface.implementation=SAM interface implementation

### org/jetbrains/plugins/scala/lang/formatting/scalafmt/ScalaFmtSuggesterService.scala
scalafmt.suggester.detected.in.project=Scalafmt configuration detected in this project
scalafmt.suggester.use.scalafmt.formatter=Use scalafmt formatter
scalafmt.suggester.continue.using.intellij.formatter=Continue using IntelliJ formatter

### org/jetbrains/plugins/scala/lang/formatting/scalafmt/ScalafmtDynamicConfigServiceImpl.scala
#Scalafmt
scalafmt.picked.new.config=Scalafmt picked up new style configuration (v{0})
scalafmt.can.not.find.config.file=Can''t find configuration file: {0}
scalafmt.can.not.find.config.file.go.to.settings=Settings...
scalafmt.can.not.find.config.file.create.new=Create new file
scalafmt.can.not.create.config.file=Can't create configuration file
scalafmt.config.load.errors.failed.to.load.config=Failed to load scalafmt config
scalafmt.config.load.errors.file.not.found=file not found
scalafmt.config.load.errors.parse.error=parse error: {0}
scalafmt.config.load.errors.unknown.error=unknown error: {0}
scalafmt.config.load.errors.cyclic.includes.detected=cyclic includes detected
scalafmt.config.load.actions.open.config.file=open config file

### org/jetbrains/plugins/scala/lang/formatting/scalafmt/ScalafmtDynamicServiceImpl.scala
scalafmt.download=download
scalafmt.resolve.again=resolve again
scalafmt.progress.resolving.scalafmt.version=Resolving scalafmt version {0}
scalafmt.progress.downloading.scalafmt.version=Downloading scalafmt version {0}
scalafmt.progress.resolving.scalafmt.version.cancel=Stop Resolving
scalafmt.progress.downloading.scalafmt.version.cancel=Stop Downloading
scalafmt.progress.version.was.downloaded=Scalafmt version {0} was downloaded
scalafmt.resolve.errors.cant.resolve.scalafmt.version=Can not resolve scalafmt version {0}
scalafmt.resolve.errors.version.is.not.downloaded.yet=Scalafmt version `{0}` is not downloaded yet.<br>Would you like to to download it?
scalafmt.resolve.errors.download.is.in.progress=Download is in progress
scalafmt.resolve.errors.downloading.error.occurred=An error occurred during downloading
scalafmt.resolve.errors.classpath.is.corrupted=Classpath is corrupted
scalafmt.resolve.errors.unknown.error=Unknown error

### org/jetbrains/plugins/scala/lang/formatting/scalafmt/dynamic/ScalafmtDynamic.scala
file.does.not.exist=file does not exist
failed.to.resolve.scalafmt.version=failed to resolve Scalafmt version ''{0}''

### org/jetbrains/plugins/scala/lang/formatting/scalafmt/processors/ScalaFmtPreFormatProcessor.scala
#0:file link;1:error message
scalafmt.format.errors.scala.file.parse.error=Scalafmt parse error ({0}):<br>{1}
#0:file link;1:error message
scalafmt.format.errors.failed.to.find.correct.surrounding.code=Scalafmt error ({0}):<br>failed to find correct surrounding code to pass for scalafmt, no formatting will be performed

### org/jetbrains/plugins/scala/lang/formatting/settings/ImportsPanel.form
imports.panel.class.count.to.use.import.with=Class count to use import with '_':
imports.panel.add.import.statement.in.closest.block=Add import statement in closest block
imports.panel.add.fully.qualified.imports=Add fully qualified imports
imports.panel.do.not.change.path.during.optimize.imports.for.local.imports=Do not change path during optimize imports for local imports
imports.panel.sort.imports.for.optimize.imports=Sort imports (for optimize imports):
imports.panel.lexicographically=lexicographically
imports.panel.scalastyle.consistent=scalastyle consistent
#TODO
imports.panel.merge.imports.with.the.same.prefix.into.one.statement=Merge imports with the same prefix into one statement
imports.panel.use.the.shortest.path.when.trying.to.import.reference.with.already.imported.name=Use the shortest path, when trying to import reference with already imported name 
imports.panel.classes.to.use.only.with.prefix=Classes to use only with prefix
imports.panel.import.layout=Import Layout
imports.panel.imports.always.marked.as.used=Imports always marked as used
except.for.base.package=Except for base package

### org/jetbrains/plugins/scala/lang/formatting/settings/ImportsPanel.java
# Imports panel
imports.panel.title=Imports
imports.panel.add.pattern.to.use.appropriate.classes.only.with.prefix=Add pattern to use appropriate classes only with prefix
imports.panel.use.references.with.prefix=Use References With Prefix:
imports.panel.no.imports.with.prefix=No imports with prefix
imports.panel.add.package.name=Add package name
imports.panel.import.layout.manager=Import Layout Manager
imports.panel.add.import.to.always.mark.it.as.used=Add import to always mark it as used
imports.panel.always.mark.as.used=Always mark as used
imports.panel.honestly.mark.imports.as.unused=Honestly mark imports as unused
imports.panel.base.package.help=If base package is <code>org.example.application</code>, a class <code>org.example.application.NAME</code> should be imported as <code>import NAME</code>

### org/jetbrains/plugins/scala/lang/formatting/settings/MultiLineStringCodeStylePanel.form
multi.line.string.panel.opening.quotes.on.new.line=Place &opening quotes on new line
multi.line.string.panel.place.closing.quotes.on.new.line.on.enter.press=Place &closing quotes on a new line on enter press
multi.line.string.panel.align.dangling.closing.quotes=&Align dangling closing quotes
multi.line.string.panel.insert.margin.char.on.enter=&Insert margin char for new lines on enter press
multi.line.string.panel.process.margin.on.copy.paste=&Strip/Insert margin on copy/paste
multi.line.string.panel.margin.char.value=Margin char:
multi.line.string.panel.margin.char.indent=Margin char indent:

### org/jetbrains/plugins/scala/lang/formatting/settings/MultiLineStringCodeStylePanel.java
#Multi-line strings panel
multi.line.string.panel.title=Multi-line Strings

### org/jetbrains/plugins/scala/lang/formatting/settings/OtherCodeStylePanel.form
other.panel.enforce.functional.syntax.for.methods.with.unit.return.type=Enforce functional syntax for methods with Unit return type
other.panel.reformat.on.compile=Reformat on compile
other.panel.replace.with.unicode.symbol=Replace '=>' with unicode symbol
other.panel.replace.with.unicode.symbol1=Replace '->' with unicode symbol
other.panel.replace.in.for.generator.with.unicode.symbol=Replace '<-' in \\"for\\" generator with unicode symbol
other.panel.kind.projector.replace.lambda.with.unicode.symbol=Kind Projector: Replace 'Lambda' with unicode symbol
other.panel.alternate.indentation.for.constructor.args.and.parameter.declarations=Alternate indentation for constructor args and parameter declarations:
other.panel.spaces=spaces
other.panel.implicit.value.class.prefix.suffix=Implicit value class prefix / suffix

### org/jetbrains/plugins/scala/lang/formatting/settings/OtherCodeStylePanel.java
#Other panel
other.panel.title=Other

### org/jetbrains/plugins/scala/lang/formatting/settings/Scala3SettingsPanel.scala
scala3.panel.use.indentation.based.syntax=Use indentation-based syntax
scala3.panel.title=Scala 3

### org/jetbrains/plugins/scala/lang/formatting/settings/ScalaCodeStyleSettings.java
#align options
wrapping.and.braces.panel.extends.do.not.align=Do not align
wrapping.and.braces.panel.extends.on.first.token=On first token
wrapping.and.braces.panel.extends.align.to.extends=Align to 'extends'

### org/jetbrains/plugins/scala/lang/formatting/settings/ScalaDocFormattingPanel.scala
#Scaladoc panel
scaladoc.panel.title=ScalaDoc
scaladoc.panel.enable.scaladoc.formatting=Enable scaladoc formatting
scaladoc.panel.add.additional.space.for.leading.asterisk=Add additional space for leading asterisk
scaladoc.panel.groups.blank.lines=Blank lines
scaladoc.panel.groups.alignment=Alignment
scaladoc.panel.groups.other=Other

### org/jetbrains/plugins/scala/lang/formatting/settings/ScalaFmtSettingsPanel.scala
scalafmt.default=Default
scalafmt.default.path=Default: {0}
#Code style panel
scalafmt.settings.panel.show.warnings.when.formatting.invalid.code=Show warnings when trying to format invalid code
scalafmt.settings.panel.use.intellij.formatter.for.code.range.formatting=Use IntelliJ formatter for code range formatting
scalafmt.settings.panel.use.intellij.formatter.for.code.range.formatting.warning.tooltip=Using Scalafmt to format code ranges can lead to code inconsistencies.<br>Scalafmt is designed to only format entire files with scala code
scalafmt.settings.panel.reformat.on.file.save=Reformat on file save
scalafmt.settings.panel.fallback.to.default.settings=Fallback to default intellij settings
scalafmt.settings.panel.configuration.label=Configuration
scalafmt.settings.panel.scalafmt.version.label=Scalafmt version
scalafmt.settings.panel.select.custom.scalafmt.configuration.file=Select custom scalafmt configuration file
scalafmt.settings.panel.no.config.found.under.path.using.default=No configuration file found under specified path
scalafmt.settings.panel.errors.cant.resolve.version=Can not resolve scalafmt version {0}
scalafmt.settings.panel.errors.failed.to.parse.config=Failed to parse configuration:<br> {0}
scalafmt.settings.panel.errors.cant.find.config.file=Can''t find scalafmt configuration file with path:<br> {0}

### org/jetbrains/plugins/scala/lang/formatting/settings/ScalaLanguageCodeStyleSettingsProvider.scala
#Spaces
spaces.panel.simple.one.line.block.braces=Simple one line block braces
spaces.panel.import.braces=Import braces
spaces.panel.self.type.braces=Self type braces
spaces.panel.before.context.bound.colon.rest=Before context bound colon (rest)
spaces.panel.before.context.bound.colon.leading.higher.kinded=Before context bound colon (leading higher-kinded)
spaces.panel.before.context.bound.colon.leading=Before context bound colon (leading)
spaces.panel.before.opening.square.bracket=Before opening square bracket
spaces.panel.keep.one.line.comments.on.same.line=Keep one-line comments on same line
spaces.panel.newline.after.annotations=Newline after annotations
spaces.panel.around.at.in.pattern.bindings=Around '@' in pattern bindings
spaces.panel.inside.closure.braces=Inside closure braces
spaces.panel.before.colon.after.declarations.name=Before colon, after declarations' name
spaces.panel.after.colon.before.declarations.type=After colon, before declarations' type
spaces.panel.method.call.left.brace=Method call left brace
spaces.panel.preserve.space.before.method.parentheses=Preserve space before method parentheses
spaces.panel.infix.method.parentheses=Infix method parentheses
spaces.panel.infix.operator.like.method.call.parentheses=Infix operator-like method call parentheses
spaces.panel.infix.method.call.parentheses=Infix method call parentheses
spaces.panel.constructor.parameters.with.modifiers=Constructor parameters with modifiers
#Wrapping and Braces
#custom groups
wrapping.and.braces.panel.groups.method.definition=Method definition
wrapping.and.braces.panel.groups.anonymous.method.definition=Anonymous method definition
wrapping.and.braces.panel.groups.class.definition=Class definition
wrapping.and.braces.panel.groups.xml.formatting=Xml formatting
wrapping.and.braces.panel.groups.tuple=Tuple
wrapping.and.braces.panel.groups.type.arguments=Type Arguments
wrapping.and.braces.panel.groups.type.parameters=Type Parameters
wrapping.and.braces.panel.force.braces=Force braces
wrapping.and.braces.panel.force.try.braces=Force 'try' braces
wrapping.and.braces.panel.force.case.branch.braces=Force 'case' branch braces
wrapping.and.braces.panel.force.finally.braces=Force 'finally' braces
wrapping.and.braces.panel.align.tuple.elements=Align tuple elements
wrapping.and.braces.panel.do.not.indent.tuples.closing.parenthesis=Do not indent tuples closing parenthesis
wrapping.and.braces.panel.do.not.align.block.expression.parameters=Do not align block expression parameters
wrapping.and.braces.panel.indent.braced.arguments=Indent braced arguments
wrapping.and.braces.panel.simple.one.line.lambdas.in.arg.list=Simple one-line lambdas in arg list
wrapping.and.braces.panel.keep.xml.formatting=Keep xml formatting
wrapping.and.braces.panel.place.self.type.on.new.line=Place self type on new line
wrapping.and.braces.panel.align.multiline.pattern.alternatives=Align multiline pattern alternatives
wrapping.and.braces.panel.align.in.columns.case.branches=Align in columns 'case' branches
wrapping.and.braces.panel.do.not.indent.case.clause.body=Do not indent case clause body
wrapping.and.braces.panel.match.statement='match' statement
wrapping.and.braces.panel.indent.first.parameter.clause.if.on.new.line=Indent first parameter clause if on new line
wrapping.and.braces.panel.indent.first.parameter.if.on.new.line=Indent first parameter if on new line
wrapping.and.braces.panel.align.parameter.types.in.multiline.declarations=Align parameter types in multiline declarations
wrapping.and.braces.panel.use.normal.indent.for.parameters=Use normal indent for parameters
wrapping.and.braces.panel.parameters.on.new.line=Parameters on new line
wrapping.and.braces.panel.wrap.before.with.keyword=Wrap before 'with' keyword
wrapping.and.braces.panel.align.if.else.statements=Align if-else statements
wrapping.and.braces.panel.indent=Indent
wrapping.and.braces.panel.new.line.options.no.new.line=No new line
wrapping.and.braces.panel.new.line.options.new.line.always=New line always
wrapping.and.braces.panel.new.line.options.new.line.for.multiple.arguments=New line for multiple arguments
wrapping.and.braces.panel.renamed.infix.expressions=Infix expressions
wrapping.and.braces.panel.renamed.extends.with.list=Extends/with list
wrapping.and.braces.panel.renamed.extends.keyword=Extends keyword
wrapping.and.braces.panel.renamed.force.yield.braces=Force yield braces
wrapping.and.braces.panel.for.indent.yield.after.one.line.enumerators=Indent yield after one-line enumerators
#Blank Lines
blank.lines.panel.around.method.in.inner.scopes=Around method in inner scopes
blank.lines.panel.around.field.in.inner.scopes=Around field in inner scopes
blank.lines.panel.around.class.in.inner.scopes=Around class in inner scopes
scaladoc.panel.align.parameter.descriptions=Align parameter descriptions
scaladoc.panel.align.throws.exception.descriptions=Align throws exception descriptions
scaladoc.panel.align.return.value.description=Align return value description
scaladoc.panel.align.other.tags.descriptions=Align other tags descriptions
scaladoc.panel.blank.lines.keep=Keep (blank lines between tags will not be removed)
scaladoc.panel.between.parameter.descriptions=Between parameter descriptions
scaladoc.panel.before.parameter.descriptions=Before parameter descriptions
scaladoc.panel.before.tags=Before tags
scaladoc.panel.after.tags=After return
scaladoc.panel.after.parameter.comments=After parameter descriptions
scaladoc.panel.preserve.spaces.in.tags=Preserve spaces in tags
align.list.items.content=Align list items content

### org/jetbrains/plugins/scala/lang/formatting/settings/ScalaTabbedCodeStylePanel.scala
scala.root.code.style.panel.formatter=Formatter:

### org/jetbrains/plugins/scala/lang/formatting/settings/TrailingCommaPanel.scala
#Trailing comma
trailing.comma.panel.title=Trailing Comma
trailing.comma.panel.keep=Keep
trailing.comma.panel.remove.when.multiline=Remove when multiline
trailing.comma.panel.add.when.multiline=Add when multiline
trailing.comma.panel.scope.arguments.list=Arguments list
trailing.comma.panel.scope.parameters.list=Parameters list
trailing.comma.panel.scope.tuple=Tuple
trailing.comma.panel.scope.tuple.type=Tuple type
trailing.comma.panel.scope.pattern.arguments.list=Pattern arguments list
trailing.comma.panel.scope.type.parameters.list=Type parameters list
trailing.comma.panel.scope.import.selector=Import selector

### org/jetbrains/plugins/scala/lang/formatting/settings/TypeAnnotationsPanelBase.form
#Use for
type.annotations.panel.use.for=Use for
type.annotations.panel.public.member=Public member
type.annotations.panel.protected.member=Protected member
type.annotations.panel.private.member=Private member
type.annotations.panel.local.definition=Local definition
type.annotations.panel.function.literal.parameter=Function literal parameter
type.annotations.panel.underscore.parameter=Underscore parameter
#Enforce for
type.annotations.panel.enforce.for=Enforce for
type.annotations.panel.implicit.definition=Implicit definition
type.annotations.panel.unit.type=Unit type
type.annotations.panel.accidental.structural.type=Accidental structural type*
type.annotations.panel.accidental.structural.type.tooltip=<html>Enforces type annotations for values, which have structural type inferred, e.g.<br>\n<pre><code>\nval foo = Runnable {\n  override def run(): Unit = ()\n  def helper(): Unit = ()\n} // foo has inferred type Runnable { def helper(): Unit } \n</code></pre></html>
#Except when
type.annotations.panel.except.when=Except when
type.annotations.panel.member.of.anonymous.class=Member of anonymous class
type.annotations.panel.member.of.private.class=Member of private class
type.annotations.panel.member.of=Member of:
type.annotations.panel.annotated.with=Annotated with:
type.annotations.panel.constant.final.val=Constant (final val)
type.annotations.panel.type.is.stable=Type is stable*
type.annotations.panel.type.is.stable.tooltip=<html><body>When right-hand side is:<br> Literal: <code>123</code>, <code>\\"string\\"</code>, etc. (excluding <code>null</code>)<br> Unit expression: <code>()</code><br> Object creation: <code>new Foo(...)</code> (excluding one with refinement: <code>new Foo() {}</code>)<br> Factory method call: <code>Foo(...)</code> (calling <code>apply(...)</code> on companion object)<br> Empty collection: <code>Seq.empty[Int]</code>, <code>Map.empty[Int, String]</code>, etc.<br> Java enum constant: <code>Enum.VALUE</code><br> An exception: <code>throw Exception()</code> </body></html>
type.annotations.panel.type.matches=Type matches:
type.annotations.panel.in.test.sources=In test sources
type.annotations.panel.in.scala.dialect.sources=In Scala dialect sources*
type.annotations.panel.in.scala.dialect.sources.tooltip=*.sbt, *.sc, etc.

### org/jetbrains/plugins/scala/lang/formatting/settings/TypeAnnotationsPanelBase.java
#Type Annotations panel
type.annotations.panel.title=Type Annotations
type.annotations.panel.classes=Classes
type.annotations.panel.annotations=Annotations
type.annotations.panel.type.patterns=Type Patterns

### org/jetbrains/plugins/scala/lang/macros/expansion/MacroExpansionLineMarkerProvider.scala
scala.meta.expand=Expand macro
undo.macro.expansion=Undo macro expansion

### org/jetbrains/plugins/scala/lang/parser/parsing/CommonUtils.scala
wrong.pattern=Wrong pattern
right.brace.expected='}' is expected
bad.interpolated.string.injection=Bad interpolated string injection
wrong.string.literal=Wrong string literal
end.of.string.expected=End of string expected

### org/jetbrains/plugins/scala/lang/parser/parsing/CompilationUnit.scala
package.qualID.expected=Package qualified identifier expected
semi.expected=';' or newline expected
out.of.compilation.unit=Out of compilation unit

### org/jetbrains/plugins/scala/lang/parser/parsing/Packaging.scala
lbrace.expected='{' expected
lbrace.or.colon.expected='{' or ':' expected
unreachable.error=Unexpected error found

### org/jetbrains/plugins/scala/lang/parser/parsing/base/AccessQualifier.scala
rsqbracket.expected=']' expected
identifier.expected=Identifier expected

### org/jetbrains/plugins/scala/lang/parser/parsing/base/Extension.scala
expected.at.least.one.extension.method=Expected at least one extension method
expected.new.line.after.colon=Expected new line after colon
extension.method.expected=Extension method expected

### org/jetbrains/plugins/scala/lang/parser/parsing/base/ImportExpr.scala
identifier.or.opening.brace.expected=Identifier or opening brace expected

### org/jetbrains/plugins/scala/lang/parser/parsing/base/ImportSelector.scala
identifier.or.wild.sign.expected=Identifier or '_' expected

### org/jetbrains/plugins/scala/lang/parser/parsing/base/ImportSelectors.scala
rbrace.expected='}' expected
import.selector.expected=Import selector expected

### org/jetbrains/plugins/scala/lang/parser/parsing/expressions/Annotation.scala
wrong.annotation.expression=Wrong annotation expression

### org/jetbrains/plugins/scala/lang/parser/parsing/expressions/ArgumentExprs.scala
rparenthesis.expected=')' expected
wrong.expression=Wrong expression

### org/jetbrains/plugins/scala/lang/parser/parsing/expressions/Ascription.scala
annotation.or.type.expected=Annotation or type expected

### org/jetbrains/plugins/scala/lang/parser/parsing/expressions/Binding.scala
wrong.type=Wrong type

### org/jetbrains/plugins/scala/lang/parser/parsing/expressions/Bindings.scala
wrong.binding=Wrong parameter

### org/jetbrains/plugins/scala/lang/parser/parsing/expressions/BlockStat.scala
wrong.declaration.in.block=Block cannot contain declarations

### org/jetbrains/plugins/scala/lang/parser/parsing/expressions/Enumerator.scala
choose.expected='<-' expected in generator statement

### org/jetbrains/plugins/scala/lang/parser/parsing/expressions/Expr1.scala
case.clauses.expected=Case clauses expected
while.expected=While keyword expected in the 'do' statement
enumerators.expected=Enumerators expected in the 'for' statement
condition.expected=Boolean condition expected
expected.then=Expected 'then'
expected.do=expected 'do'
expected.do.or.yield=Expected 'do' or 'yield'

### org/jetbrains/plugins/scala/lang/parser/parsing/expressions/ExprInIndentationRegion.scala
line.is.indented.too.far.to.the.left=Line is indented too far to the left

### org/jetbrains/plugins/scala/lang/parser/parsing/expressions/NameValuePair.scala
assign.expected='=' expected

### org/jetbrains/plugins/scala/lang/parser/parsing/expressions/Quoted.scala
type.expected=Type expected

### org/jetbrains/plugins/scala/lang/parser/parsing/expressions/ResultExpr.scala
fun.sign.expected='=>' expected

### org/jetbrains/plugins/scala/lang/parser/parsing/params/FunTypeParamClause.scala
wrong.parameter=Wrong parameter

### org/jetbrains/plugins/scala/lang/parser/parsing/params/ImplicitParamClause.scala
implicit.params.excepted=Implicit parameter clause must have at least one parameter

### org/jetbrains/plugins/scala/lang/parser/parsing/params/ParamClauses.scala
param.clause.expected=Parameter clause expected

### org/jetbrains/plugins/scala/lang/parser/parsing/params/TypeParam.scala
variance.annotation.not.allowed=Variance annotation is not allowed here
context.bounds.not.allowed=Context bounds are not allowed here
view.bounds.not.allowed=View bounds are not allowed here

### org/jetbrains/plugins/scala/lang/parser/parsing/params/TypesAsParamsOrParams.scala
expected.more.types=Expected more types

### org/jetbrains/plugins/scala/lang/parser/parsing/patterns/CaseClause.scala
pattern.expected=Pattern expected

### org/jetbrains/plugins/scala/lang/parser/parsing/patterns/Guard.scala
wrong.postfix.expression=Wrong postfix expression

### org/jetbrains/plugins/scala/lang/parser/parsing/patterns/Pattern3.scala
wrong.type.associativity=Wrong associativity. All operators should have the same associativity
simple.pattern.expected=Illegal start of simple pattern

### org/jetbrains/plugins/scala/lang/parser/parsing/statements/FunDef.scala
wrong.constr.expression=Wrong constructor expression
expected.parameter.clause.for.extension.method=Expected parameter clause for extension method
auxiliary.constructor.may.not.have.a.type.annotation=Auxiliary constructor may not have a type annotation
auxiliary.constructor.definition.expected=Auxiliary constructor definition expected

### org/jetbrains/plugins/scala/lang/parser/parsing/statements/PatDef.scala
expression.expected=Expression expected
expected.another.pattern=Expected another pattern

### org/jetbrains/plugins/scala/lang/parser/parsing/statements/ValDcl.scala
wrong.val.declaration=Wrong value declaration

### org/jetbrains/plugins/scala/lang/parser/parsing/statements/VarDcl.scala
wrong.var.declaration=Wrong variable declaration

### org/jetbrains/plugins/scala/lang/parser/parsing/top/Parents.scala
wrong.simple.type=Wrong simple type

### org/jetbrains/plugins/scala/lang/parser/parsing/top/QualId.scala
wrong.qual.identifier=Wrong qualified identifier

### org/jetbrains/plugins/scala/lang/parser/parsing/top/TmplDef.scala
wrong.case.modifier=Wrong case modifier. Use it with class or object

### org/jetbrains/plugins/scala/lang/parser/parsing/top/params/ClassParam.scala
colon.expected=':' expected
parameter.type.expected=Parameter type expected
val.var.expected=Val or var keyword expected

### org/jetbrains/plugins/scala/lang/parser/parsing/top/template/GivenDef.scala
expected.with=Expected with

### org/jetbrains/plugins/scala/lang/parser/parsing/top/template/TemplateBody.scala
def.dcl.expected=Definition or declaration expected

### org/jetbrains/plugins/scala/lang/parser/parsing/types/ExistentialClause.scala
existential.block.expected=Existential clause expected

### org/jetbrains/plugins/scala/lang/parser/parsing/types/ExistentialDclSeq.scala
wrong.existential.declaration=Wrong existential declaration. It must be type or value declaration

### org/jetbrains/plugins/scala/lang/parser/parsing/types/InfixType.scala
compound.type.expected=Compound type expected

### org/jetbrains/plugins/scala/lang/parser/parsing/types/MatchTypeSuffix.scala
match.type.cases.expected=Match type case clauses expected
expected.case.on.a.new.line=Expected case on a new line

### org/jetbrains/plugins/scala/lang/parser/parsing/types/PolyFunOrTypeLambda.scala
type.lambda.expected='=>>' expected

### org/jetbrains/plugins/scala/lang/parser/parsing/types/SimpleType.scala
identifier.expected.comma.found=Identifier expected, but ',' found

### org/jetbrains/plugins/scala/lang/parser/parsing/types/StableId.scala
dot.expected='.' expected
dot.or.cq.expected='.' or class qualifier expected

### org/jetbrains/plugins/scala/lang/parser/parsing/xml/AttrValue.scala
xml.attribute.end.expected=Xml attribute value end delimiter expected

### org/jetbrains/plugins/scala/lang/parser/parsing/xml/Attribute.scala
xml.eq.expected='=' expected
xml.attribute.value.expected=Attribute value expected

### org/jetbrains/plugins/scala/lang/parser/parsing/xml/CDSect.scala
xml.cdata.end.expected=Xml CData end expected

### org/jetbrains/plugins/scala/lang/parser/parsing/xml/Comment.scala
xml.comment.end.expected=Xml comment end ('-->') expected
xml.wrong.character=Wrong character in xml comment

### org/jetbrains/plugins/scala/lang/parser/parsing/xml/ETag.scala
xml.tag.end.expected=Xml tag end expected
xml.name.expected=Xml tag name expected

### org/jetbrains/plugins/scala/lang/parser/parsing/xml/Element.scala
xml.end.tag.expected=Xml end tag ('</' name '>') expected

### org/jetbrains/plugins/scala/lang/parser/parsing/xml/PI.scala
xml.PI.end.expected=Xml proccessing instructions end expected

### org/jetbrains/plugins/scala/lang/parser/parsing/xml/ScalaExpr.scala
xml.scala.injection.end.expected=Scala injection end ('}') in xml expected
xml.scala.expression.exected=Scala expression expected in injection in xml

### org/jetbrains/plugins/scala/lang/parser/parsing/xml/pattern/ScalaPatterns.scala
xml.scala.patterns.exected=Scala patterns expected in injection in xml

### org/jetbrains/plugins/scala/lang/psi/api/base/types/ScTypeElement.scala
recursive.type.of.type.element=Recursive type of type element
cannot.desugarize.typename=Cannot desugarize {0}

### org/jetbrains/plugins/scala/lang/psi/api/expr/ScBlock.scala
cannot.find.partialfunction.class=Cannot find PartialFunction class
cannot.find.throwable.class=Cannot find Throwable class
cannot.infer.type.without.expected.type=Cannot infer type without expected type
cannot.infer.type.without.function.expected.type=Cannot infer type without expected type of scala.FunctionN or scala.PartialFunction

### org/jetbrains/plugins/scala/lang/psi/api/expr/ScExpression.scala
no.type.inferred=No type inferred for the expression ''{0}''

### org/jetbrains/plugins/scala/lang/psi/api/statements/ScTypeAliasDefinition.scala
no.alias.type=No alias type

### org/jetbrains/plugins/scala/lang/psi/compiled/SigFileViewProviderFactory.scala
file.type.scala.outlines=Scala outlines
could.not.decompile.file.comment=//couldn''t decompile {0}

### org/jetbrains/plugins/scala/lang/psi/impl/base/ScConstructorInvocationImpl.scala
can.t.resolve.type=Cannot resolve type
java.constructors.only.have.one.parameter.section=Java constructors only have one parameter section
has.no.reference=Has no reference

### org/jetbrains/plugins/scala/lang/psi/impl/base/ScInterpolatedStringLiteralImpl.scala
cannot.find.method.of.stringcontext=Cannot find method {0} of StringContext

### org/jetbrains/plugins/scala/lang/psi/impl/base/literals/ScLiteralImplBase.scala
wrong.psi.for.literal.type="Wrong element to get Literal type"

### org/jetbrains/plugins/scala/lang/psi/impl/base/patterns/ScConstructorPatternImpl.scala
cannot.resolve.unknown.symbol=Cannot resolve symbol

### org/jetbrains/plugins/scala/lang/psi/impl/base/patterns/ScNamingPatternImpl.scala
no.expected.type.for.wildcard.naming=No expected type for wildcard naming

### org/jetbrains/plugins/scala/lang/psi/impl/base/patterns/ScPatternImpl.scala
cannot.type.pattern=Cannot type pattern

### org/jetbrains/plugins/scala/lang/psi/impl/base/patterns/ScReferencePatternImpl.scala
cannot.define.expected.type=Cannot define expected type

### org/jetbrains/plugins/scala/lang/psi/impl/base/patterns/ScTypedPatternImpl.scala
no.type.element.for.type.pattern=No type element for type pattern
no.type.pattern=No type pattern

### org/jetbrains/plugins/scala/lang/psi/impl/base/patterns/ScWildcardPatternImpl.scala
cannot.determine.expected.type=cannot determine expected type

### org/jetbrains/plugins/scala/lang/psi/impl/base/types/ScDependentFunctionTypeElementImpl.scala
dependent.function.types.are.not.yet.supported=Dependent function types are not yet supported

### org/jetbrains/plugins/scala/lang/psi/impl/base/types/ScMatchTypeElementImpl.scala
match.types.are.not.yet.supported=Match types are not yet supported

### org/jetbrains/plugins/scala/lang/psi/impl/base/types/ScPolyFunctionTypeElementImpl.scala
polymorphic.function.types.are.not.yet.supported=Polymorphic function types are not yet supported

### org/jetbrains/plugins/scala/lang/psi/impl/base/types/ScSimpleTypeElementImpl.scala
cannot.find.template.for.this.reference=Cannot find template for this reference
cannot.find.enclosing.container=Cannot find enclosing container
cannot.resolve.ref=Cannot resolve reference
unknown.macro.in.type.position=Unknown macro in type position
recursive.non.value.type.of.type.element=Recursive non value type of type element

### org/jetbrains/plugins/scala/lang/psi/impl/base/types/ScTypeLambdaTypeElementImpl.scala
scala.3.type.are.not.yet.supported=Scala 3 type are not yet supported

### org/jetbrains/plugins/scala/lang/psi/impl/base/types/ScTypeProjectionImpl.scala
cannot.resolve.reference=Cannot resolve reference

### org/jetbrains/plugins/scala/lang/psi/impl/expr/MethodInvocationImpl.scala
suitable.method.not.found=Suitable method not found

### org/jetbrains/plugins/scala/lang/psi/impl/expr/ScForImpl.scala
cannot.create.expression=Cannot create expression

### org/jetbrains/plugins/scala/lang/psi/impl/expr/ScGenericCallImpl.scala
not.a.polymorphic.lambda=Not a polymorphic lambda.

### org/jetbrains/plugins/scala/lang/psi/impl/expr/ScIfImpl.scala
nothing.to.type=Nothing to type

### org/jetbrains/plugins/scala/lang/psi/impl/expr/ScNewTemplateDefinitionImpl.scala
empty.new.expression=Empty new expression

### org/jetbrains/plugins/scala/lang/psi/impl/expr/ScParenthesisedExprImpl.scala
no.expression.in.parentheseses=No expression in parentheseses

### org/jetbrains/plugins/scala/lang/psi/impl/expr/ScReferenceExpressionImpl.scala
no.declared.type.found=No declared type found
case.class.has.no.primary.constructor=Case Class has no primary constructor
cannot.resolve.expression=Cannot resolve expression

### org/jetbrains/plugins/scala/lang/psi/impl/expr/ScSelfInvocationImpl.scala
not.enough.parameter.sections=Not enough parameter sections
cannot.shape.resolve.self.invocation=Cannot shape resolve self invocation

### org/jetbrains/plugins/scala/lang/psi/impl/expr/ScSuperReferenceImpl.scala
cannot.infer.type.of.super.expression=Cannot infer type of `super' expression

### org/jetbrains/plugins/scala/lang/psi/impl/expr/ScThisReferenceImpl.scala
cannot.infer.type=Cannot infer type
no.clazz.type.found=No class type found

### org/jetbrains/plugins/scala/lang/psi/impl/expr/ScUnderscoreSectionImpl.scala
typed.statement.is.not.complete.for.underscore.section=Typed statement is not complete for underscore section
failed.to.found.corresponging.underscore.section=Failed to found corresponding underscore section
could.not.infer.type.of.underscore.section=Could not infer type of underscore section
no.type.inferred.for.unknown.expression=No type inferred for the expression

### org/jetbrains/plugins/scala/lang/psi/impl/expr/xml/ScXmlPatternImpl.scala
not.found.scala.xml.node=not found scala.xml.Node

### org/jetbrains/plugins/scala/lang/psi/impl/statements/ScFunctionImpl.scala
both.stub.and.name.identifier.node.are.null=Both stub and name identifier node are null for {0} \n{1}
no.defined.return.type=No defined return type

### org/jetbrains/plugins/scala/lang/psi/impl/statements/ScValueDeclarationImpl.scala
no.type.element.found=No type element found in ''{0}''

### org/jetbrains/plugins/scala/lang/psi/impl/statements/ScVariableDefinitionImpl.scala
cannot.infer.type.without.an.expression=Cannot infer type without an expression

### org/jetbrains/plugins/scala/lang/psi/impl/statements/params/ScParameterImpl.scala
wrong.stub.problem=Wrong Stub problem
wrong.type.element=Wrong type element

### org/jetbrains/plugins/scala/lang/psi/impl/toplevel/typedef/ScGivenAliasImpl.scala
scgivenaliasimpl.returntype.not.yet.implemented=ScGivenAliasImpl.returnType: not yet implemented

### org/jetbrains/plugins/scala/lang/psi/impl/toplevel/typedef/ScTypeDefinitionImpl.scala
cannot.resolve.parent.class=Cannot resolve parent class

### org/jetbrains/plugins/scala/lang/psi/light/DummyLightTypeParam.scala
no.containing.file=No containing file

### org/jetbrains/plugins/scala/lang/psi/types/Compatibility.scala
assignment.missing.right.side=Assignment missing right side
cannot.handle.compatibility.for=Cannot handle compatibility for {0}

### org/jetbrains/plugins/scala/lang/psi/types/api/Variance.scala
variance.contravariant=contravariant
variance.covariant=covariant
variance.invariant=invariant
variance.bivariant=bivariant

### org/jetbrains/plugins/scala/lang/psi/types/recursiveUpdate/RecursiveUpdateException.scala
type.mismatch.after.update.method=Type mismatch after update method

### org/jetbrains/plugins/scala/lang/psi/types/result/package.scala
no.element.found=No element found

### org/jetbrains/plugins/scala/lang/rearranger/RearrangerUtils.scala
#Rearranger panel
rearranger.panel.keep.scala.style.getters.and.setters.together=Keep scala-style getters and setters together
rearranger.panel.keep.java.style.getters.and.setters.together=Keep java-style getters and setters together
rearranger.panel.split.into.unarrangeable.blocks.by.expressions=Split into unarrangeable blocks by expressions
rearranger.panel.split.into.unarrangeable.blocks.by.implicits=Split into unarrangeable blocks by implicits

### org/jetbrains/plugins/scala/lang/refactoring/changeSignature/ConflictsUtil.scala
by.name.parameters.cannot.be.used=This method has java overriders, by-name parameters of value classes cannot be used.
method.is.overridden.by.class.parameter.of.class=Method is overridden by class parameter of {0}. Converting it to a function definition is not supported.
updating.of.usages.of.generated.unapply=Updating of usages of generated `unapply` methods is not supported
method.is.overridden.in.a.composite.pattern.definition=Method is overridden in a composite pattern definition in {0}. Converting it to function definition is not supported.
method.is.overridden.in.a.composite.variable.definition=Method is overridden in a composite variable definition in {0}. Converting it to function definition is not supported.

### org/jetbrains/plugins/scala/lang/refactoring/changeSignature/DefaultValuesUsagePanel.scala
default.values=Default values:
add.to.definition=Add to definition
modify.method.calls=Modify method calls

### org/jetbrains/plugins/scala/lang/refactoring/changeSignature/ScalaChangeSignatureDialog.scala
change.signature.vararg.should.be.last.in.clause=Vararg parameter should be the last in parameter clause
change.signature.parameters.same.name.{0}=Parameters have same name: {0}
change.signature.add.parameter.clause=Add parameter clause
change.signature.remove.parameter.clause=Remove parameter clause
default.value.is.missing.default.arguments=Default value is missing. Default arguments will contain blanks instead of the new parameter value.
default.value.is.missing.method.calls=Default value is missing. Method calls will contain blanks instead of the new parameter value.
specify.result.type=Specify result type
default.ta.settings=Settings

### org/jetbrains/plugins/scala/lang/refactoring/changeSignature/ScalaChangeSignatureHandler.scala
error.wrong.caret.position.method.name=The caret should be positioned at the name of the method to be refactored.
change.signature.not.supported.implicit.functions=Change signature is not supported for implicit functions
change.signature.not.supported.implicit.parameters=Change signature is not supported for functions with implicit parameters
change.signature.not.supported.extractors=Change signature is not supported for extractors

### org/jetbrains/plugins/scala/lang/refactoring/changeSignature/ScalaParameterTableModelItem.scala
change.signature.specify.type.for.parameter=Specify type for parameter ''{0}''
parameter.could.not.be.repeated.and.by.name=Parameter could not be repeated and by-name in the same time
could.not.understand.type=Could not understand type {0}

### org/jetbrains/plugins/scala/lang/refactoring/extractMethod/ScalaExtractMethodDialog.java
extract.method.title=Extract Method
default.ta.tooltip=Configure type annotation settings

### org/jetbrains/plugins/scala/lang/refactoring/extractMethod/ScalaExtractMethodHandler.scala
cannot.extract.used.function.definition=Refactoring is not supported: function definition inside selection is used outside of the selected fragment
extract.method.cannot.find.possible.scope=Cannot find possible scope for extracted method
extract.local.method=Extract local method in {0}
extract.method.to.object.name=Extract method to object {0}
extract.method.to.class.name=Extract method to class {0}
extract.method.to.trait.name=Extract method to trait {0}
extract.method.to.anonymous.class=Extract method to anonymous class
try.block=try block
constructor=constructor
case.clause=case clause
if.block=if block
def.name=def {0}
extract.local.method.in.else.block=Extract local method in else block
val.name=val {0}
var.name=var {0}
for.statement=for statement
while.statement=while statement
do.statement=do statement
function.expression=function expression
code.block=code block
extract.file.method=Extract file method
unknown.extraction=Unknown extraction
choose.level.for.extract.method=Choose level for Extract Method

### org/jetbrains/plugins/scala/lang/refactoring/extractMethod/duplicates/DuplicatesUtil.scala
process.duplicates=Process Duplicates

### org/jetbrains/plugins/scala/lang/refactoring/extractTrait/ExtractSuperUtil.scala
choose.class=Choose class
cannot.find.package.with.name=Cannot find package with name: {0}
cannot.find.directory.for.package=Cannot find directory for package: {0}
class.already.exists.in.package=Class with name {0} already exists in the package {1}

### org/jetbrains/plugins/scala/lang/refactoring/extractTrait/ScalaExtractTraitAction.scala
extract.trait.action.text=Extract Trait...
extract.trait.action.description=Extract trait from the selected class

### org/jetbrains/plugins/scala/lang/refactoring/extractTrait/ScalaExtractTraitDialog.java
extract.trait.title=Extract Trait
extract.trait.top.label.text=Extract trait from:
extract.trait.name=Trait name:
extract.trait.package.label=Package for new trait:
members.to.extract=Members to extract
extract.abstracts=extract abstracts

### org/jetbrains/plugins/scala/lang/refactoring/extractTrait/ScalaExtractTraitHandler.scala
private.member.cannot.be.used.in.extracted.member=Private member {0} cannot be used in the extracted member {1}
member.of.anonymous.class.cannot.be.used.in.extracted.member=Member {0} of an anonymous class cannot be used in the extracted member {1}
super.reference.used.in.extracted.member=Extracted member {0} has reference to super, but extracted trait will not have a base class
type.parameters.for.self.type.not.supported=Extracted trait will have {0} as a self type, but identification of it''s type parameters is not supported

### org/jetbrains/plugins/scala/lang/refactoring/inline/ScalaInlineHandler.scala
cannot.inline.different.files=Member is declared in the other file. Inline is not supported.
cannot.inline.used.outside.class=Member is used outside of the containing class. Inline is not supported.
cannot.inline.stable.reference=Value is used in a stable reference and cannot be inlined
cannot.inline.never.used=Variable is never used.
cannot.inline.not.simple.pattern=Inline is supported only for simple pattern definitions
cannot.inline.recursive.function=Inline is not supported for recursive functions
cannot.inline.function.implicit.parameters=Inline is not supported for functions with implicit parameters
cannot.inline.function.multiple.clauses=Inline is not supported for functions with several parameter clauses
cannot.inline.function.varargs=Inline is not supported for functions with varargs parameter
cannot.inline.implicit.element=Inline is not supported for implicit elements
cannot.inline.special.function=Inline is not supported for special functions
cannot.inline.generic.function=Inline is not supported for generic functions
cannot.inline.notsimple.typealias=Inline is supported only for simple type alias
cannot.inline.value.functional.type=Inline of values with functional types is not supported
cannot.inline.function.functional.parameters=Inline of functions with functional parameters is not supported
cannot.inline.parameter=Inline is not supported for parameters
cannot.inline.not.method.call=Inline is supported for regular method calls only

### org/jetbrains/plugins/scala/lang/refactoring/introduceField/ScalaIntroduceFieldDialog.java
introduce.field.title=Extract Field
field.occurrences={0} occurrences

### org/jetbrains/plugins/scala/lang/refactoring/introduceField/ScalaIntroduceFieldFromExpressionHandler.scala
cannot.refactor.not.expression=Selected string cannot be extracted as expression
cannot.create.field.from.this.expression=Cannot create field from this expression
cannot.find.place.for.the.new.field=Cannot find place for the new field
choose.class.for.introduce.field=Choose class for Introduce Field

### org/jetbrains/plugins/scala/lang/refactoring/introduceParameter/ScalaIntroduceParameterDialog.scala
parameter.label.name=Name:
parameter.label.type=Type:
parameter.label.default.value=Default value:
replace.all.occurrences=Replace all occurrences

### org/jetbrains/plugins/scala/lang/refactoring/introduceParameter/ScalaIntroduceParameterHandler.scala
cannot.refactor.no.function=Can't find function for introduce parameter
introduce.parameter.title=Introduce Parameter
refactoring.is.not.supported.contains.return=Refactoring is not supported: selection contains return statement
choose.function.for.refactoring=Choose function for {0}

### org/jetbrains/plugins/scala/lang/refactoring/introduceVariable/IntroduceExpressions.scala
introduce.variable.title=Introduce Value / Variable

### org/jetbrains/plugins/scala/lang/refactoring/introduceVariable/IntroduceTypeAlias.scala
cannot.refactor.not.valid.type=Type element should be selected
cannot.refactor.scope.not.found=No suitable class or package was found
choose.scope.for=Choose Scope for {0}
introduce.type.alias.title=Introduce Type Alias

### org/jetbrains/plugins/scala/lang/refactoring/introduceVariable/ScalaInplaceTypeAliasIntroducer.scala
command.introduce.type.alias=Introduce Type Alias
press.hotkey.to.show.more.options=Press ctrl + alt + v to show dialog with more options

### org/jetbrains/plugins/scala/lang/refactoring/introduceVariable/ScalaInplaceVariableIntroducer.scala
introduce.variable.declare.as.var=&Variable
introduce.variable.specify.type.explicitly=Specify type
introduce.variable.identifier.is.not.valid=Identifier is not valid

### org/jetbrains/plugins/scala/lang/refactoring/introduceVariable/ScalaIntroduceTypeAliasDialog.java
replace.all.x.occurrences=Replace all {0} occurrences
1.occurrence=(1 occurrence)
multi.occurrences=({0} occurrences)
replace.occurrences.available.from.companion.class=Replace occurrences available from companion class {0}

### org/jetbrains/plugins/scala/lang/refactoring/introduceVariable/ScalaIntroduceVariableHandler.scala
cannot.refactor.not.expression.nor.type=Expression or type element should be selected
press.escape.to.remove.the.highlighting=Press escape to remove the highlighting

### org/jetbrains/plugins/scala/lang/refactoring/memberPullUp/ScalaPullUpProcessor.scala
pull.up.members.from=Pull up members from
class.to.pull.up.members.to.class=Class to pull up members to {0}

### org/jetbrains/plugins/scala/lang/refactoring/move/ScalaMoveClassesOrPackagesHandler.scala
move.to.inner.is.not.supported.title=Refactoring is not supported
move.to.inner.is.not.supported=Move class to inner is not supported for Scala
move.with.companion=Move together with the companion

### org/jetbrains/plugins/scala/lang/refactoring/move/members/ScalaMoveMemberHandler.scala
target.0.already.contains.definition.of.1=<b>{0}</b> already contains definition of member <b>{1}</b>

### org/jetbrains/plugins/scala/lang/refactoring/move/members/ScalaMoveMembersDialog.scala
move.members.source.title=Move member from object:
move.members.target.title=To object:
move.members.object.name.or.qualified.name.expected=Name or qualified name of scala object expected
move.members.cannot.find.object=Cannot find object with such name

### org/jetbrains/plugins/scala/lang/refactoring/move/members/ScalaMoveMembersHandler.scala
move.members=Move members
move.members.supported.only.stable.objects=Move refactoring is supported only for stable object members
move.members.not.supported.implicits=Move refactoring is not supported for implicit definitions
move.members.not.supported.overridden=Move refactoring is not supported for overridden definitions

### org/jetbrains/plugins/scala/lang/refactoring/rename/RenameScalaClassProcessor.scala
rename.companion.module=Rename companion {0}

### org/jetbrains/plugins/scala/lang/refactoring/rename/RenameScalaMethodProcessor.scala
rename.getters.and.setters.title=Function has getters or setters with same name. Rename them as well?

### org/jetbrains/plugins/scala/lang/refactoring/rename/RenameSuperMembersUtil.scala
rename.all.base.members=Rename all base members
rename.base.member=Rename base member
rename.only.current.member=Rename only current member
rename.has.multiple.base.members={0} has multiple base members
rename.only.in=Rename only in {0} {1}
name.implements.member.of.qualname={0} implements member of {1}
name.overrides.member.of.qualname={0} overrides member of {1}

### org/jetbrains/plugins/scala/lang/refactoring/rename/inplace/ScalaInplaceRenameHandler.scala
rename.special.method.title=This method can not be renamed
rename.special.method.rename.class=Rename containing {0}
rename.cancel=Cancel
rename.aliased.title=Renaming of import aliases is not supported
rename.aliased.rename.actual=Rename actual element

### org/jetbrains/plugins/scala/lang/refactoring/rename/inplace/ScalaMemberInplaceRenamer.scala
rename=Rename
could.not.perform.inplace.rename=Could not perform inplace rename:\nelement to rename: {0} {1}\nsubstituted: {2}\naround caret: {3}

### org/jetbrains/plugins/scala/lang/refactoring/ui/ScalaMemberInfoBase.scala
presentable.definition.unnamed=unnamed
presentable.type.unnamed=unnamed type

### org/jetbrains/plugins/scala/lang/refactoring/util/ScalaRefactoringUtil.scala
only.for.scala=This works only with scala files
cannot.refactor.constr.expression=Selected block shouldn't be presented as constructor expression
cannot.refactor.under.generic.call=Refactoring is not supported in generic calls
cannot.refactor.arg.in.self.invocation.of.constructor=Refactoring is not supported for arguments of self-invocation in the constructor body
cannot.refactor.named.arg=Refactoring is not supported for named arguments
cannot.refactor.literal.pattern=Refactoring is not supported for literal patterns
cannot.refactor.class.parameter.top.level=Refactoring is not supported for parameters of top level classes
cannot.refactor.interpolated.string.prefix=Refactoring is not supported for interpolated string prefix
cannot.refactor.self.invocation=Refactoring is not supported for the constructor call in auxiliary constructor
refactoring.is.not.supported.in.guard=Refactoring is not supported in guards, it most likely break code structure
file.is.not.writable=File hasn't access to be writable
cannot.extract.empty.message=Wrong selection for the refactoring. Number of complete expressions or statements expected.
cannot.extract.self.invocation=Cannot extract self invocation.
cannot.extract.used.type.definition=Refactoring is not supported: type definition inside selection is used outside of the selected fragment
choose.expression.for=Choose Expression for {0}
choose.type.element.for=Choose Type Element for {0}

### org/jetbrains/plugins/scala/lang/refactoring/util/ScalaTypeValidator.scala
introduced.typeAlias.will.conflict.with.type.name=Introduced type alias conflicts with type name: {0}
introduced.typeAlias.will.conflict.with.class.name=Introduced type alias conflicts with class name: {0}

### org/jetbrains/plugins/scala/lang/refactoring/util/ScalaVariableValidator.scala
introduced.variable.will.conflict.with.local=Introduced variable conflicts with (or may be hidden by) local variable: {0}
introduced.variable.will.conflict.with.parameter=Introduced variable conflicts with (or may be hidden by) parameter: {0}
introduced.variable.will.conflict.with.field=Introduced variable will conflicts with (or may be hidden by) field or method \
  without parameters: {0}
introduced.variable.will.conflict.with.class.parameter=Introduced variable conflicts with (or may be hidden by) class parameter: {0}

### org/jetbrains/plugins/scala/lang/resolve/processor/MethodResolveProcessor.scala
not.all.type.parameters.are.defined=not all type parameters are defined. typeargs=[{0}] and classTypeParams=[{1}]

### org/jetbrains/plugins/scala/lang/scaladoc/generate/ScaladocAction.scala
generate.scaladoc=Generate Scaladoc
generate.scaladoc.action.text=Generate Scaladoc
generate.scaladoc.action.description=Generate scaladoc
scaladoc.noon=Scaladoc

### org/jetbrains/plugins/scala/lang/scaladoc/generate/ScaladocConsoleRunConfigurationForm.java
output.dir=Output dir
documentation.for.project={0} documentation

### org/jetbrains/plugins/scala/lang/scaladoc/parser/parsing/MyScaladocParsing.scala
scaladoc.parsing.open.syntax.element=Open syntax element
scaladoc.parsing.closing.link.tag.before.opening=Closing link tag before opening
scaladoc.parsing.closing.code.tag.before.opening=Closing code tag before opening
scaladoc.parsing.error.bad.token=Error: Bad token: {0}
scaladoc.parsing.header.closed.by.opening.new.one=Header closed by opening new one
scaladoc.parsing.wiki.syntax.element.closed.by.message=Wiki syntax element closed by {0}
scaladoc.parsing.wiki.syntax.closed.by.new.paragraph=new paragraph
scaladoc.parsing.wiki.syntax.closed.by.tag=tag
scaladoc.parsing.wiki.syntax.closed.by.inner.code.tag=inner code tag
scaladoc.parsing.closing.link.element.before.opening.one=Closing link element before opening one
scaladoc.parsing.cross.tags=Cross tags
scaladoc.parsing.no.closing.element=No closing element
scaladoc.parsing.unclosed.code.tag=Unclosed code tag
scaladoc.parsing.unexpected.end.of.tag.body=Unexpected end of tag body
scaladoc.parsing.inline.tag=Inline tag
scaladoc.parsing.missing.tag.param=Missing tag param
scaladoc.parsing.unknown.tag=Unknown tag: {0}

### org/jetbrains/plugins/scala/lang/structureView/element/TypeAlias.scala
type.unnamed=type unnamed

### org/jetbrains/plugins/scala/lang/surroundWith/surrounders/scaladoc/ScalaDocWithBoldSurrounder.scala
bold.surrounder.template.description=Bold: ''' '''

### org/jetbrains/plugins/scala/lang/surroundWith/surrounders/scaladoc/ScalaDocWithItalicSurrounder.scala
italic.surrounder.template.description=Italic: '' ''

### org/jetbrains/plugins/scala/lang/surroundWith/surrounders/scaladoc/ScalaDocWithMonospaceSurrounder.scala
monospace.surrounder.template.description=Monospace: ` `

### org/jetbrains/plugins/scala/lang/surroundWith/surrounders/scaladoc/ScalaDocWithSubscriptSurrounder.scala
subscript.surrounder.template.description=Subscript: ,, ,,

### org/jetbrains/plugins/scala/lang/surroundWith/surrounders/scaladoc/ScalaDocWithSuperscriptSurrounder.scala
superscript.surrounder.template.description=Superscript: ^ ^

### org/jetbrains/plugins/scala/lang/surroundWith/surrounders/scaladoc/ScalaDocWithUnderlinedSurrounder.scala
underline.surrounder.template.description=Underline: __ __

### org/jetbrains/plugins/scala/lang/transformation/DesugarCodeAction.scala
desugar.scala.code.in.scope=Desugar Scala code ({0})
scope.selection=selection
scope.file=file
desugar.scala.code.action.text=Desugar Scala Code...
desugar.scala.code.action.description=Desugar Scala code (selection / whole file)

### org/jetbrains/plugins/scala/lang/transformation/SelectionDialog.scala
column.enabled=Enabled
column.transformation=Transformation
desugar.group.method.invocations=Method invocations
desugar.expand.apply.call=Expand "apply" call
desugar.expand.update.call=Expand "update" call
desugar.expand.unary.call=Expand unary call
desugar.expand.property.setter.call=Expand property setter call
desugar.expand.assignment.call=Expand assignment call
desugar.expand.dynamic.call=Expand dynamic call
desugar.canonize.infix.call=Canonize infix call
desugar.canonize.postfix.call=Canonize postfix call
desugar.canonize.arity.0.call=Canonize arity-0 call
desugar.canonize.block.argument=Canonize block argument
desugar.expand.auto.tupling=Expand auto-tupling
desugar.expand.vararg.argument=Expand vararg argument
desugar.inscribe.default.arguments=Inscribe default arguments
desugar.expand.to.equals.call=Expand "==" to "equals" call
desugar.group.type.annotations=Type annotations
desugar.value.definition=Value definition
desugar.variable.definition=Variable definition
desugar.method.definition=Method definition
desugar.function.parameter=Function parameter
desugar.underscore.parameter=Underscore parameter
desugar.reference.pattern=Reference pattern
desugar.type.parameters=Type parameters
desugar.group.types=Types
desugar.expand.function.type=Expand function type
desugar.expand.tuple.type=Expand tuple type
desugar.expand.type.alias=Expand type alias
desugar.expand.context.bound=Expand context bound
desugar.expand.view.bound=Expand view bound
desugar.substitute.anyref=Substitute AnyRef
desugar.group.implicits=Implicits
desugar.expand.implicit.conversion=Expand implicit conversion
desugar.inscribe.implicit.parameters=Inscribe implicit parameters
desugar.group.functions=Functions
desugar.expand.placeholder.syntax=Expand placeholder syntax
desugar.expand.eta.expansion=Expand eta expansion
desugar.make.eta.expansion.explicit=Make eta-expansion explicit
desugar.expand.single.abstract.methods=Expand single abstract methods
desugar.expand.function.instantiation=Expand function instantiation
desugar.group.expressions=Expressions
desugar.expand.for.comprehensions=Expand for comprehensions
desugar.expand.string.interpolation=Expand string interpolation
desugar.expand.tuple.instantiation=Expand tuple instantiation
desugar.group.declarations=Declarations
desugar.expand.procedure.syntax=Expand procedure syntax
desugar.make.method.return.expressions.explicit=Make method return expressions explicit
desugar.add.explicit.override.modifier=Add explicit "override" modifier
desugar.replace.underscore.section.with.default.value=Replace underscore section with default value
desugar.expand.property.declaration=Expand property declaration
desugar.expand.property.definition=Expand property definition
desugar.convert.implicit.class.to.class.and.function=Convert implicit class to class and function
desugar.group.references=References
desugar.expand.wildcard.import=Expand wildcard import
desugar.fully.qualify.import.expression=Fully qualify import expression
desugar.partially.qualify.simple.reference=Partially qualify simple reference
desugar.fully.qualify.reference=Fully qualify reference
desugar.group.general=General
desugar.append.semicolon=Append semicolon
desugar.inscribe.explicit.braces=Inscribe explicit braces
desugar.enforce.parentheses.in.constructor.invocation=Enforce parentheses in constructor invocation
desugar.convert.parentheses.to.braces.in.for.comprehensions=Convert parentheses to braces in for comprehensions
desugar.expand.macro=Expand macro

### org/jetbrains/plugins/scala/overrideImplement/ScalaMemberChooser.scala
specify.return.type.explicitly=Specify &type
add.override.modifier=Insert "&override"
copy.scaladoc=Copy &ScalaDoc

### org/jetbrains/plugins/scala/overrideImplement/ScalaOIUtil.scala
select.method.override=Select Members to Override
select.method.implement=Select Members to Implement
action.implement.method=Implement method
action.override.method=Override method

### org/jetbrains/plugins/scala/project/CompileOrderDescriptions.scala
compile.order.mixed=Mixed
compile.order.java.then.scala=Java then Scala
compile.order.scala.then.java=Scala then Java

### org/jetbrains/plugins/scala/project/DebuggingInfoLevelDescription.scala
debug.info.level.none=None
debug.info.level.source=Source file attribute
debug.info.level.source.and.line.number=Source and line number information
debug.info.level.source.line.number.and.local.variable=Source, line number and local variable information
debug.info.level.complete.no.tail.call.optimization=Complete, no tail call optimization

### org/jetbrains/plugins/scala/project/ScalaLibraryType.scala
library.type.scala.sdk=Scala SDK

### org/jetbrains/plugins/scala/project/Versions.scala
title.fetching.available.this.versions=Fetching available {0} versions

### org/jetbrains/plugins/scala/project/converter/ScalaProjectConverterProvider.scala
scala.facets.will.be.converted.to.scala.sdks=Scala facets will be converted to Scala SDKs

### org/jetbrains/plugins/scala/project/notification/AbstractNotificationProvider.scala
setup.kittitle=Setup {0}

### org/jetbrains/plugins/scala/project/notification/SetupJdkNotificationProvider.scala
project.jdk.is.not.defined=Project JDK is not defined
kit.title.jdk=JDK

### org/jetbrains/plugins/scala/project/notification/SetupScalaSdkNotificationProvider.scala
sdk.title=Scala SDK
no.kittitle.in.module=No {0} in module

### org/jetbrains/plugins/scala/project/notification/source/AttachSourcesUtil.java
module.libraries.attach.sources.immediately.button=Attach sources...
multiple.libraries.contain.file="Multiple libraries contain file.<br> Choose libraries to attach sources to."

### org/jetbrains/plugins/scala/project/notification/source/ScalaAttachSourcesNotificationProvider.scala
library.sources.not.found=Sources not found
library.sources.not.attached=Sources not attached
cannot.find.library.for=Cannot find library for {0}
cannot.find.library.error.title=Error

### org/jetbrains/plugins/scala/project/sdkdetect/ScalaSdkProvider.scala
sdk.scan.title=Locating Scala SDKs: {0}

### org/jetbrains/plugins/scala/project/sdkdetect/repository/BrewDetector.scala
brew.packages=Brew packages

### org/jetbrains/plugins/scala/project/sdkdetect/repository/CoursierDetector.scala
coursier.v1.cache=Coursier v1 cache

### org/jetbrains/plugins/scala/project/sdkdetect/repository/IvyDetector.scala
ivy2.cache=Ivy2 cache

### org/jetbrains/plugins/scala/project/sdkdetect/repository/MavenDetector.scala
maven.local.repo=Maven local repo

### org/jetbrains/plugins/scala/project/sdkdetect/repository/ProjectLocalDetector.scala
local.project.libraries=Local project libraries

### org/jetbrains/plugins/scala/project/sdkdetect/repository/SdkmanDetector.scala
sdkman=SDKMAN!

### org/jetbrains/plugins/scala/project/sdkdetect/repository/SystemDetector.scala
system.wide.scala=System-wide Scala

### org/jetbrains/plugins/scala/project/settings/ScalaCompilerConfigurable.scala
scala.compiler=Scala Compiler

### org/jetbrains/plugins/scala/project/settings/ScalaCompilerConfigurationPanel.form
#Scala compiler settings UI
incrementality.type=&Incrementality type:

### org/jetbrains/plugins/scala/project/settings/ScalaCompilerProfilesPanel.scala
scala.compiler.profiles.panel.profile.name=Profile Name
scala.compiler.profiles.panel.move.to=Move To
scala.compiler.profiles.panel.create.new.profile=Create New Profile
scala.compiler.profiles.panel.profile.should.not.be.empty=Profile name shouldn't be empty
scala.compiler.profiles.panel.profile.already.exists=Profile {0} already exists

### org/jetbrains/plugins/scala/project/settings/ScalaCompilerSettingsPanel.form
unchecked.warnings=&Unchecked warnings
unchecked.warnings.tooltip=Enable additional warnings where generated code depends on assumptions.
deprecation.warnings=&Deprecation warnings
deprecation.warnings.tooltip=Emit warning and location for usages of deprecated APIs.
feature.dynamics=&Dynamics
feature.existential.types=&Existential types
explain.type.errors=&Explain type errors
explain.type.errors.tooltip=Explain type errors in more detail
feature.warnings=&Feature warnings
feature.warnings.tooltip=Emit language feature warnings.
feature.higher.kinded.types=&Higher-kinded types
feature.implicit.conversions=&Implicit conversions
feature.macros=&Macros
optimise.bytecode=&Optimise bytecode (use with care*)
optimise.bytecode.tooltip=Generates faster bytecode by applying optimisations to the program. May trigger various compilation problems. Use with care.
feature.postfix.notation=&Postfix operator notation
feature.reflective.calls=&Reflective calls
additional.compiler.options=Additional compiler &options:
compile.order=Compile &order:
compiler.plugins=Compiler plugins
debugging.info.level=Debugging info &level:
feature.experimental.features=E&xperimental Features
enable.continuations=Enable &continuations
enable.specialization=Enable &specialization
enable.specialization.tooltip=Respect @specialize annotations
enable.warnings=Enable &warnings
enable.warnings.tooltip=Generate warnings
features=Features
options=Options

### org/jetbrains/plugins/scala/project/template/ScalaFilesChooserDescriptor.scala
title.scala.sdk.files=Scala SDK files
choose.either.a.scala.sdk.directory.or.scala.jar.files=Choose either a Scala SDK directory or Scala jar files (allowed: binaries, sources, docs)

### org/jetbrains/plugins/scala/project/template/ScalaModuleBuilder.scala
package.prefix.label=Package prefix:
package.prefix.example=Such as 'org.example.application'
package.prefix.help=If package prefix is <code>org.example.application</code>, a <code>PATH</code> in a source directory implies <code>org/example/application/PATH</code>, so you don't have to create explicit <code>org</code>, <code>example</code>, and <code>application</code> subdirectories.

### org/jetbrains/plugins/scala/project/template/ScalaProjectTemplate.scala
idea.based.scala.project=IDEA-based Scala project
module.with.a.scala.sdk=Module with a Scala SDK

### org/jetbrains/plugins/scala/project/template/ScalaSdkDescriptor.scala
not.found.missing.artifacts=Not found: {0}

### org/jetbrains/plugins/scala/project/template/SdkSelectionDialog.java
sdk.create.select.files=Select JAR's for the new Scala SDK
sdk.create.missing.version=No Scala version {0} in the Ivy repository

### org/jetbrains/plugins/scala/project/template/SdkTableModel.scala
sdk.table.model.location=Location
sdk.table.model.version=Version
sdk.table.model.sources=Sources
sdk.table.model.docs=Docs

### org/jetbrains/plugins/scala/project/template/VersionDialog.scala
title.download=Download
title.error.downloading.scala.libraries=Error Downloading Scala libraries
no.versions.available.for.download=No versions available for download
downloading.scala.version=Downloading Scala {0}
error.downloading.scala.version=Error downloading Scala {0}

### org/jetbrains/plugins/scala/runner/ScalaApplicationConfigurationExtension.scala
execution.cancelled=Execution cancelled

### org/jetbrains/plugins/scala/runner/view/ScalaMainMethodParametersTable.scala
main.method.parameters.table.column.title.name=Name
main.method.parameters.table.column.title.type=Type
main.method.parameters.table.column.title.value=Value

### org/jetbrains/plugins/scala/runner/view/ScalaProvideMainMethodParametersDialog.scala
provide.program.arguments=Provide program arguments

### org/jetbrains/plugins/scala/settings/ScalaEditorSmartKeysConfigurable.scala
insert.pair.multiline.quotes=Insert pair quotes for multiline string
wrap.single.expression.body=Wrap single expression body with closing brace after typing '{'
upgrade.to.interpolated=Upgrade simple string into interpolated after typing '${'
insert.block.braces.automatically.based.on.indentation=Add braces automatically
remove.block.braces.automatically.based.on.indentation=Remove braces automatically
control.curly.braces.based.on.line.indents=Control curly braces based on line indentation:

### org/jetbrains/plugins/scala/settings/ScalaProjectSettings.java
scala.project.settings=Scala Project Settings

### org/jetbrains/plugins/scala/settings/ScalaProjectSettingsPanel.form
scala.project.settings.form.tabs.editor=Editor
scala.project.settings.form.tabs.project.view=Project View
scala.project.settings.form.tabs.performance=Performance
scala.project.settings.form.tabs.worksheet=Worksheet
scala.project.settings.form.tabs.base.packages=Base Packages
scala.project.settings.form.base.package.inherit=Inherit from Package Prefix of a Source Folder
scala.project.settings.form.base.package.custom=Use custom:
scala.project.settings.form.tabs.misc=Misc
scala.project.settings.form.tabs.updates=Updates
scala.project.settings.form.tabs.extensions=Extensions
scala.project.settings.form.collection.type.highlighting.option=Collection type highlighting:
scala.project.settings.form.sbt.index.ivy2.mode=Local ivy2 cache indexing mode
scala.project.settings.form.sbt.index.ivy2.mode.hint=Disabled - no indexing done at all\nMetadata - only index library names and versions, used in SBT file dependency completion\nClasses - also index class names in cache, used by "Add sbt dependency" quickfix
scala.project.settings.form.scala.meta.settings.annot212=Execution of scala.meta programs
scala.project.settings.form.scala.meta.settings.annot212.tooltip=Due to binary incompatibility, annotations in 2.12 modules have to use\\  very slow string-based serialization and reparsing. This may seriously affect overall performance.
scala.project.settings.form.scala.meta.settings.modeOptions.tooltip=Enabled - all metaprograms are executed during type inference\nDisabled - \\  metaprograms are skipped during type inference\nManual - metaprograms run only when manually expanded
scala.project.settings.form.scala.meta.settings.trimBodies.caption=Trim method bodies expanded by scala.meta
scala.project.settings.form.scala.meta.settings.trimBodies.tooltip=Rely on explicit return types of generated methods(bodies are replaced with ???). Speeds up type inference by skipping method body typechecking.
scala.project.settings.form.show.type.info.on.mouse.hover=Show type info on mouse hover after, ms
scala.project.settings.form.highlighting=Highlighting
scala.project.settings.form.highlight.implicit.conversions=Highlight implicit conversions
scala.project.settings.form.show.hints.if.no.implicit.arguments.found=Show hints if no implicit arguments found
scala.project.settings.form.show.hints.if.ambiguous.implicit.arguments.found=Show hints if ambiguous implicit arguments found
scala.project.settings.form.highlight.arguments.to.by.name.parameters=Highlight arguments to by-name parameters
scala.project.settings.form.include.block.expressions=Include block expressions
scala.project.settings.form.include.literals=Include literals
scala.project.settings.form.custom.scalatest.keywords.highlighting=Custom scalaTest keywords highlighting
scala.project.settings.form.autocomplete=Autocomplete
scala.project.settings.form.ahead.of.time.completion=Ahead-of-time completion (parameter and variable names)
scala.project.settings.form.use.scala.classes.priority.over.java=Use Scala classes priority over Java classes
scala.project.settings.form.code.conversion=Code Conversion
scala.project.settings.form.convert.java.code.to.scala.on.copy.paste=Convert Java code to Scala on copy-paste
scala.project.settings.form.automatically.convert.to.scala.code.without.dialog=Don't show dialog on paste and automatically convert to Scala code
scala.project.settings.form.add.override.keyword.to.method.implementation=Add override keyword to method implementation
scala.project.settings.form.group.package.object.with.package=&Group package object with package
scala.project.settings.form.highlight.nodes.with.errors=&Highlight nodes with errors
scala.project.settings.form.implicit.parameters.search.depth=Implicit parameters search depth (-1 for none):
scala.project.settings.form.search.all.symbols=Search all symbols (include locals)
scala.project.settings.form.disable.parsing.of.documentation.comments=Disable parsing of documentation comments. This may improve editor performance for very large files. (SCL-2900)
scala.project.settings.form.disable.language.injection.in.scala.files=Disable language injection in Scala files (injected languages may freeze typing with auto popup completion)
scala.project.settings.form.dont.cache.compound.types=Don't cache compound types (use it in case of big pauses in GC)
scala.project.settings.form.treat.sc.files.as=Treat .sc files as:
scala.project.settings.form.output.cutoff.limit=Output cutoff limit:
scala.project.settings.form.output.cutoff.limit.units=lines
scala.project.settings.form.delay.before.auto.run=Delay before auto-run:
scala.project.settings.form.delay.before.auto.run.units=milliseconds
scala.project.settings.form.run.worksheet.in.the.compiler.process=Run worksheet in the compiler process (Plain mode only)
scala.project.settings.form.use.eclipse.compatibility.mode=Use \"eclipse compatibility\" mode
scala.project.settings.form.treat.scala.scratch.files.as.worksheet.files=Treat Scala scratch files as worksheet files
scala.project.settings.form.collapse.long.output.by.default=Collapse long output by default
scala.project.settings.form.scalatest.default.super.class=ScalaTest default super class:
scala.project.settings.form.trailing.commas=Trailing commas:
scala.project.settings.form.plugin.update.channel=Update channel:
scala.project.settings.form.check.for.updates=Check Now
scala.project.settings.form.info=You can always select "Stable Release" or "Early Access Program" to revert to a more stable build.

### org/jetbrains/plugins/scala/settings/ScalaProjectSettingsPanel.java
scala.collection.highlighting.type.none=None
scala.collection.highlighting.type.only.non.qualified=Only non-qualified
scala.collection.highlighting.type.all=All
scala.plugin.chanel.nightly=Nightly Builds
scala.plugin.chanel.eap=Early Access Program
scala.plugin.chanel.release=Stable Releases
scala.project.settings.form.tabs.base.package=Base package
scala.meta.mode.enabled=Enabled
scala.meta.mode.disabled=Disabled
scala.meta.mode.manual=Manual
ivy2.indexing.mode.disabled=Disabled
ivy2.indexing.mode.metadata=Metadata
ivy2.indexing.mode.classes=Classes
trailing.commas.mode.enabled=Enabled
trailing.commas.mode.disabled=Disabled
trailing.commas.mode.auto=Auto
script.file.mode.always.worksheet=Always Worksheet
script.file.mode.ammonite.in.test.sources.otherwise.worksheet=Ammonite in test sources, otherwise Worksheet
script.file.mode.always.ammonite=Always Ammonite
invalid.update.channel=Invalid Update Channel
changes.in.scalatest.highlighting.will.be.processed...=Changes in ScalaTest highlighting will be processed correctly only on freshly highlighted files. For best experience please restart Intellij IDEA
base.package.help=<html>If base package is <code>org.example.application</code>, a package <code>org.example.application.NAME</code> should be defined as<br><code>package org.example.application</code><br><code>package NAME</code></html>

### org/jetbrains/plugins/scala/testDiscovery/ScalaAffectedTestsInChangeListPainter.java
show.affected.tests.scala=show affected tests (scala)

### org/jetbrains/plugins/scala/testDiscovery/actions/DiscoveredTestsTree.java
no.tests.captured=No tests captured for {0}

### org/jetbrains/plugins/scala/testDiscovery/actions/ScalaShowAffectedTestsAction.java
show.affected.tests.action.text=Show Affected Tests (Scala)
show.affected.tests.action.description=Show affected tests (Scala)
run.all.affected.tests.scala=Run All Affected Tests (Scala)
affected.tests.title.empty.selection=Empty Selection
affected.tests.title.two.tests={0} and {1}
affected.tests.title.more.than.two={0} et al.
selected.changes=Selected Changes
tests.for.title=Tests for {0}
open.find.usages.tool.window=Open Find Usages Tool window{0}

### org/jetbrains/plugins/scala/testingSupport/test/AbstractTestRunConfiguration.scala
test.run.config.multiple.suite.traits.detected=Multiple suite traits detected: {0}
test.framework.is.not.specified={0} is not specified

### org/jetbrains/plugins/scala/testingSupport/test/MyInheritorChooser.scala
test.config.choose.executable.classes.to.run.test=Choose executable classes to run {0}

### org/jetbrains/plugins/scala/testingSupport/test/ScalaTestFrameworkCommandLineStateLike.scala
test.run.config.module.is.not.specified=Module is not specified

### org/jetbrains/plugins/scala/testingSupport/test/munit/MUnitCommandLineState.scala
munit.command.line.state.no.tests.found=No tests found

### org/jetbrains/plugins/scala/testingSupport/test/munit/MUnitConfigurationType.scala
munit.config.display.name=MUnit
munit.config.description=MUnit testing framework run configuration

### org/jetbrains/plugins/scala/testingSupport/test/scalatest/ScalaTestConfigurationProducer.scala
test.in.scope.scalatest.presentable.text=ScalaTests in ''{0}''

### org/jetbrains/plugins/scala/testingSupport/test/scalatest/ScalaTestConfigurationType.scala
scalatest.config.display.name=ScalaTest
scalatest.config.description=ScalaTest testing framework run configuration

### org/jetbrains/plugins/scala/testingSupport/test/specs2/Specs2ConfigurationProducer.scala
test.in.scope.specs2.presentable.text=Specs2 in ''{0}''

### org/jetbrains/plugins/scala/testingSupport/test/specs2/Specs2ConfigurationType.scala
specs2.config.display.name=Specs2
specs2.config.description=Specs2 testing framework run configuration

### org/jetbrains/plugins/scala/testingSupport/test/structureView/TestNodeProvider.scala
test.node.provider.show.scala.tests=Show scala tests

### org/jetbrains/plugins/scala/testingSupport/test/testdata/AllInPackageTestData.scala
test.run.config.test.package.not.found=Test package not found: {0}
test.config.package.does.not.exist=Package doesn't exist
test.config.can.nott.run.while.indexing.no.class.names.memorized.from.previous.iterations=Can't run while indexing: no class names memorized from previous iterations.
test.config.did.not.find.suite.classes.in.package=Did not find suite classes in package {0}

### org/jetbrains/plugins/scala/testingSupport/test/testdata/ClassTestData.scala
test.run.config.test.class.not.found=Test class not found: {0}
test.config.test.class.is.not.specified=Test Class is not specified
test.config.test.class.not.found.in.module=Test Class ''{0}'' not found in module ''{1}''
test.config.no.suite.class.is.found.for.class.in.module=No Suite Class is found for Class ''{0}'' in module ''{1}''
test.config.class.is.not.inheritor.of.suite.trait=Class ''{0}'' is not inheritor of Suite trait
test.config.clazz.is.not.a.valid.test.suite={0} is not a valid test suite

### org/jetbrains/plugins/scala/testingSupport/test/testdata/RegexpTestData.scala
test.config.failed.to.compile.pattern=Failed to compile pattern {0}
test.config.no.patterns.detected=No patterns detected
test.config.cant.run.while.indexing.no.class.names.memorized.from.previous.iterations=Can't run while indexing: no class names memorized from previous iterations.

### org/jetbrains/plugins/scala/testingSupport/test/testdata/SingleTestData.scala
test.config.test.name.is.not.specified=Test Name is not specified
test.config.multiple.classes.specified.for.single.test.run=Multiple classes specified for single-test run

### org/jetbrains/plugins/scala/testingSupport/test/ui/RegexpPanel.scala
test.run.config.for.class.pattern=Class pattern
test.run.config.test.pattern=Test pattern

### org/jetbrains/plugins/scala/testingSupport/test/ui/ScalaTestRunLineMarkerProvider.scala
scalatest.gutter.run.test=Run Test

### org/jetbrains/plugins/scala/testingSupport/test/ui/TestRunConfigurationForm.scala
test.run.config.test.kind=&Test kind:
test.run.config.test.class=Test &Class:
test.run.config.test.name=Test &Name:
test.run.config.regular.expressions=Regular e&xpressions:
test.run.config.test.package=Test Packa&ge:
test.run.config.search.for.tests=Search for tests:
test.run.config.use.sbt=Use sb&t
test.run.config.use.ui.with.sbt=Use UI with sbt
test.run.config.print.information.messages.to.console=&Print information messages to console
test.run.config.choose.test.class=Choose Test Class
test.run.config.test.kind.all.in.package=All in package
test.run.config.test.kind.class=Class
test.run.config.test.kind.test.name=Test name
test.run.config.test.kind.regular.expression=Regular expression
test.run.config.search.scope.in.whole.project=In whole project
test.run.config.search.scope.in.single.module=In single module
test.run.config.search.scope.across.module.dependencies=Across module dependencies

### org/jetbrains/plugins/scala/testingSupport/test/utest/UTestConfigurationProducer.scala
test.in.scope.utest.presentable.text=UTests in ''{0}''

### org/jetbrains/plugins/scala/testingSupport/test/utest/UTestConfigurationType.scala
utest.config.display.name=utest
utest.config.description=utest testing framework run configuration

### org/jetbrains/plugins/scala/util/NotificationUtil.scala
default.notification.title=Warning

### <unused>
expected.indented.package.statement=Expected indented package statement
expected.indented.template.body=Expected indented template body
type.declaration.expected=type declaration expected
advanced.settings=Advanced settings
match.type.expected=Match type expected
scala.3.disclaimer=Scala 3 disclaimer
conversion.is.not.available.in.it.s.own.definition=Conversion is not available in it's own definition
element.has.incompatible.type.parameter.bounds.for.type={0} has incompatible type parameter bounds for {1}
type.does.not.conform.to.type={0} does not conform to {1}
import.implicitInstance.chooser.title=Select implicit instance to import
family.name.search.implicit.instances=Search implicit instances
search.implicit.instances.for=Search implicit instances for {0}
choose.type.to.search=Choose type to search
applicable.implicits.not.found=Applicable implicits not found
test.run.config.choose.working.directory=Choose Working Directory
sdk.build.title=Building SDKs
statement.expected=Block statement expected
star.expected='*' expected
case.clauses.or.qualified.reference.expected=Case clauses or qualified reference expected
annotation.expected=Annotation expected
simple.type.expected.requires=Simple type expected in requires block
type.dcl.expected=Type declaration expected
block.expected=Block expected
type.tale.expected=Type keyword expected in simple type tale
refined.type.expected=Refined type expected
this.expected='this' keyword expected
arg.expr.expected=Argument expression expected
# TODO unify type mismatch messages
expr.type.does.not.conform={0} type in expression doesn''t conform to value declared type
# TODO unify type mismatch messages
patt.type.does.not.conform.expr.type=Expected type for pattern {0} doesn''t conform to expression type {1}
title.cache.updating=Updating caches
title.cache.creating=Creating caches
title.cache.files.scanning=Scanning files...
title.cache.files.parsing=Parsing new files...
title.please.wait=Please wait
title.cache.saving=Saving caches
title.cache.datafile.loading=Loading caches
title.cache.files.removing=Removing old caches
title.cache.loading=Loading caches
error.report.to.jetbrains.action=Report To Jetbrains
error.report.submit.label=<html>This error report will be created as new <b>JIRA</b> issue \
  <br><b>''{0}''</b><br>at \
  <b><a href="{1}{2}">{1}{2}</a></b> <br>as component <b>''{3}''</b>.\
  <br><br>Please provide a short description of the error and how can it be reproduced:</html>
error.report.submit.register.in.jira=<html><a href="{0}">Signup for an account</a></html>
error.report.submit.new.issue.url=<html>Your issue was successfully added, see<br>     <a href="{0}">{0}</a></html>
error.report.submit.new.issue.title=Issue Added
error.report.wrong.login=Invalid username or password.
error.report.canceled=Canceled sending report
error.report.error.creating.issue=Error creating new JIRA issue
error.report.jira.issue=JetScala issue #{0}
error.report.dialog.title=Submit Error
error.report.dialog.wrong.password.title=Sending Failed
error.report.button.sendreport.caption=&Send Report
error.report.button.cancel.caption=&Cancel
error.report.form.not.jira=&I do not have a JIRA account, create issue on behalf of 'JetScala error reporter'
error.report.form.jira=I'm a &JIRA user
error.report.form.jira.login=&Login
error.report.form.jira.password=&Password
error.report.form.jira.password.save=Save password
repetitive.method.name.signature=Repetitive method name/signature
repetitive.method.name.signature.and.return.type=repetitive method name, signature and return type
illegal.combination.of.modifiers=illegal combination of modifiers
modifier.is.not.allowed.here.0=modifier ''{0}'' is not allowed here
illegal.combination.of.modifiers.abstract.and.final=illegal combination of modifiers 'abstract' and 'final'
modifier.volatile.not.allowed.here=modifier 'volatile' not allowed here
modifier.transient.not.allowed.here=modifier 'transient' not allowed here
intarface.cannot.have.modifier.final=interface cannot have modifier 'final'
script.cannot.have.modifier.abstract=script cannot have modifier 'abstract'
script.cannot.have.modifier.native=script cannot have modifier 'native'
interface.must.have.no.static.method=interface must have no static method
not.abstract.class.cannot.have.abstract.method=not abstract class cannot have abstract method
illegal.combination.of.modifiers.volatile.and.final=illegal combination of modifiers 'volatile' and 'final'
variable.cannot.be.native=variable cannot have modifier 'native'
variable.cannot.be.abstract=variable cannot have modifier 'abstract'
not.abstract.class.cannot.have.method.without.body=not abstract class cannot have method without body
not.abstract.method.should.have.body=not abstract method should have body
cannot.create.class.error.text=Cannot Create Class ''{0}'': {1}
cannot.create.class.error.title=Cannot Create Class
no.class.in.file.template=No Class Found in File Template
interface.must.have.no.private.method=interface must have no private method
error.external=External error
Inner.methods.are.not.supported=Inner methods are not supported
final.class.cannot.be.extended=Final class cannot be extended
element.is.not.accessible=Element {0} has private access from this place
class.must.declared.abstract=Class ''{0}'' must be declared abstract or implement inherited abstract members
object.must.implement=Object ''{0}'' must implement not implemented methods
cannot.refactor.constructor.parameter.top.level=Refactoring is not supported for constructor parameters in top level classes
wrong.refactoring.context=Refactoring is not supported in current context
operation.not.supported.in.current.block=Operation is not supported in current block
class.import.title=Add import for class:
0.is.not.a.legal.scala.identifier=''{0}'' is not a legal scala identifier
cannot.have.implicit.parameters.and.implicit.bounds=Cannot have both implicit parameters and context bounds `: ...' or view bounds `<% ...' on type parameters
block.must.end.result.expression=Block must end in result expression
illegal.cyclic.reference=Illegal cyclic reference ''{0}''
anonymous.class.must.declared.abstract=Anonymous class must implement inherited abstract members
cyclic.reference.type=Illegal cyclic reference involving type {0}
implicit.usage.tooltip=<html>\
  <body>\
  Implicit conversion {0}(<b>{1}</b>): <b>{2}</b> detected
implicit.usage.message=Implicit conversion ''{0}({1}): {2}'' detected.
suspicicious.inference=Inferred type of {0} is suspicious. If you really want this, explicitly annotate the type.
suspicicious.newline=Newline before argument list is not inferred as a semicolon. Consider using '.' before the method name.
# TODO Remove? (or even better, do show a clarification, just as the scalac does)
missing.arguments.for.method=Missing arguments for method {0} and is not a partially applied function. Add more arguments or insert a placeholder.
element.of.trait=of trait
element.of.class=of class
element.method=method
label.method=Method {0}
method.has.supers=Method {0} overrides/implements some base method, rename it as well?
remove.explicit.val=Remove explicit 'val'
maven.repository.presentable.name=Maven repository
config.display.name=Configuration
scala.facet.title=Sca&la
config.scala.libraries=Configure Scala libraries
scala.config.label=Scala installation directory
scala.config.dscr=Please specify path to Scala installation directory
scala.config.noscala.title=Scala Configuration Error
scala.config.download.link=https://www.scala-lang.org/downloads/
scala.config.download.link.label=Scala is available for download on:
scala.config.compiler.library=Scala comp&iler library:
scala.config.sdk.library=Scala &SDK library:
scala.config.sdk.space.hint=Several paths must be separated by file separator - ';'
scala.config.take.compiler.from.settings=Use Scala compiler &libraries from specified jars
scala.config.take.relative.path=Use relative path towards the project root
error.scala.path.not.valid=Scala path is not valid
scala.config.project.template.name=Non-sbt
scala.config.project.template.description=Module for developing Scala Application
scala.config.project.settings.title=Scala Settings
scala.config.module.name=Scala Module
scala.config.module.description=Create Scala Module
no.java.sdk=No java SDK configured
cannot.compile.scala.files.no.facet=Please attach a Scala facet to module.
cannot.compile.scala.files.no.compiler=Please, specify compiler library in Scala facet.
cannot.compile.scala.files.compiler.problem=Please, adjust compiler library in Scala facet: {0}.
cannot.compile.scala.files.no.sdk=Please, set up Java SDK for module ''{0}''.
cannot.compile.scala.files.no.sdk.mult=Please, Set up Java SDK for modules ''{0}''.
cannot.compile=Cannot compile Scala files
debug.option=Enable debug stacktrace
scalac.compiler.name=Scalac
javac.error.tools.jar.missing=Cannot obtain path javac classes for JDK {0}.\nUpdate JDK configuration.
javac.error.unknown.jdk.version=Cannot determine version for JDK {0}.\nUpdate JDK configuration.
different.scala.sdk.in.modules=Dependent modules must have equal Scala SDK versions
scala.compiler.description=Scala compiler
jtype.is.not.found=Cannot compile Scala files.\nch.epfl.lamp.fjbg.JType class is not found. \nPlease, attach appropriate jar to the module ''{0}''.
scala.sdk.configuration=Scala SDK configuration
new.button.label=New
scala.sdk.configuration.label=<html><b>Scala SDK:</b><br>Choose Scala SDK specific for this module</html>
add.new.scala.lib=New Scala SDK
invalid.scala.sdk.path.text=Wrong path specified
duplicate.scala.lib.version=Duplicated Scala SDK version
duplicate.scala.lib.version.add=Add one more Scala SDK of version {0}?
scala.sdk.combo.box.project.item=<No Scala SDK>
no.scala.facet=Scala Facet expected
new.scala.facet.detected=Scala Facet detected
invalid.scala.sdk.path.message=Invalid path to Scala SDK
facet.create.lib.title=Create Scala library
facet.create.project.lib=Create &Project-level Scala library ''{0}''
facet.create.application.lib=Create &Application-level Scala library ''{0}''
facet.setting.exclude.compiler.from.cp=Exclude Scala Com&piler library from module scope
facet.setting.exclude.library.from.cp=Exclude Scala SDK &library from module scope
file.template.group.title.scala=Scala
# class
newclass.dlg.prompt=Enter name for new Scala Class
newclass.dlg.title=New Scala Class
newclass.command.name=Create Scala Class
newclass.progress.text=Creating Scala Class ''{0}''
# worksheet
newworksheet.dlg.prompt=Enter name for new Scala Worksheet
newworksheet.dlg.title=New Scala Worksheet
newworksheet.menu.action.text=Scala Worksheet
newworksheet.menu.action.description=Creates new Scala Worksheet
newworksheet.command.name=Create Scala Worksheet
newworksheet.progress.text=Creating Scala Worksheet ''{0}''
#object
newobject.dlg.prompt=Enter name for new Scala object
newobject.dlg.title=New Scala Object
newobject.menu.action.text=Scala Object
newobject.menu.action.description=Creates new Scala Object
newobject.command.name=Create Scala Object
newobject.progress.text=Creating Scala Object ''{0}''
#trait
newtrait.dlg.prompt=Enter name for new Scala Trait
newtrait.dlg.title=New Scala Trait
newtrait.menu.action.text=Scala Trait
newtrait.menu.action.description=Creates new Scala Trait
newtrait.command.name=Create Scala Trait
newtrait.progress.text=Creating Scala Trait ''{0}''
scala.compiler.option.additional.command.line.parameters=Scala compiler additional command line parameters
psi.decompiled.text.header=\
  // IntelliJ API decompiler for Scala language\n\
  // Stub source generated from a class file\n\
  // Implementation of functions is not available
scala.compiler.heap.size=Maximum heap size (MB):
scala.compiler.cmd.line.params=Command line parameters
scala.compiler.use.deprecation=Compile @&deprecated annotations
scala.compiler.scalac.first=Compile &Scala files first
scala.compiler.show.unchecked=Compile @&unchecked annotations
scala.compiler.generate.no.warnings=Generate no &warnings
scala.compiler.optimize=&Optimise bytecode
scala.compiler.no.generics=Suppress Scala &generic signatures
no.right.operand.found=No right operand found
cannot.resolve.infix.operator=Cannot resolve infix operator
circular.dependency.detected=Circular dependency detected for the type alias ''{0}''
no.result.expression.found=No result expression found
unreachable.expression=Unreachable statement
choose.inferred.or.super.type.popup.title=Select Type
test.in.scope.specs.presentable.text=Specs in ''{0}''
equals.between.inconvertible.types.display.name=Equality test between objects of inconvertible types
equals.between.inconvertible.types.description=Detects equality tests that will always return false, because the static type of the operands are inconvertible.
equals.between.inconvertible.types.problem.descriptor=Equality test between objects of inconvertible types ''{0}'' and ''{1}'' #loc
find.usages.implementing.type.definition=Implementing Type Definitions
find.usages.companin.module=Companion module usages
find.usages.instances.title=Instance Creation
introduce.typealias.search.companion=Raplace from companion
introduce.typealias.search.inheritors=Replace in inheritors
introduce.field.choose.class=Choose class for Introduce Field
extract.trait.name.not.specified=No trait name specified
change.signature.not.supported.multiple.parameter.clauses=Change signature is not supported for functions with multiple parameter clauses
change.signature.not.supported.constructors=Change signature in scala is not supported for constructors
parameter.not.from.function=Evaluation from parameter not from function definition or function expression
local.variable.from.anonymous.class=Cannot load local variable {0} from anonymous class
invalid.expression.in.parentheses=Invalid expression in parentheses: {0}
formatted.interpolator.not.supported=Formatted string interpolator f"..." is not supported in scala 2.11
gradle.dataService.scalaVersionCantBeDetected=Cannot determine Scala compiler version for module {0}
gradle.dataService.scalaLibraryIsNotFound=Cannot find project Scala library {0} for module {1}
configure.type.aware.highlighting=Configure type-aware highlighting for the project
vm.options=VM options:
console.arguments=Console arguments:
working.directory=Working directory:
use.classpath.and.sdk.of.module=Use classpath and SDK of module:
test.run.config.sbt.runner.form.environment.variables=&Environment variables
scala.project.settings.form.compiler.highlighting=Use compiler for error highlighting
scala.project.settings.form.compiler.highlighting.tooltip=Use error messages directly from the compiler instead of the built-in highlighter. This will result in error highlighting that is more precise, but may show up more slowly and lack features.
