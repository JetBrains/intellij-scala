#
# Copyright 2000-2008 JetBrains s.r.o.
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
# https://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
#

#
# Copyright 2000-2007 JetBrains s.r.o.
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
# https://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
#

#
# Copyright 2000-2006 JetBrains s.r.o.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
# https://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
#


########################################################################################################################
# Load SDK
########################################################################################################################
sdk.title=Scala SDK
sdk.scan.title=Locating Scala SDKs: {0}
sdk.build.title=Building SDKs

########################################################################################################################
# Parser error messages
########################################################################################################################
statement.expected=Block statement expected
package.qualID.expected=Package qualified identifier expected
lbrace.expected='{' expected
rbrace.expected='}' expected
rsqbracket.expected=']' expected
rparenthesis.expected=')' expected
semi.expected=';' or newline expected
choose.expected='<-' expected in generator statement
assign.expected='=' expected
star.expected='*' expected
colon.expected=':' expected
parameter.type.expected=Parameter type expected
case.clauses.expected=Case clauses expected
case.clauses.or.qualified.reference.expected=Case clauses or qualified reference expected
while.expected=While keyword expected in the 'do' statement
enumerators.expected=Enumerators expected in the 'for' statement
wrong.qual.identifier=Wrong qualified identifier
identifier.expected=Identifier expected
identifier.or.wild.sign.expected=Identifier or '_' expected
dot.expected='.' expected
dot.or.cq.expected='.' or class qualifier expected
out.of.compilation.unit=Out of compilation unit
wrong.var.declaration=Wrong variable declaration
wrong.val.declaration=Wrong value declaration
wrong.type=Wrong type
wrong.parameter=Wrong parameter
wrong.case.modifier=Wrong case modifier. Use it with class or object
wrong.import.statment.end=Wrong import statment tale
wrong.expression=Wrong expression
wrong.postfix.expression=Wrong postfix expression
wrong.existential.declaration=Wrong existential declaration. It must be type or value declaration
wrong.annotation.expression=Wrong annotation expression
wrong.pattern=Wrong pattern
wrong.binding=Wrong parameter
annotation.expected=Annotation expected
type.expected=Type expected
annotation.or.type.expected=Annotation or type expected
import.selector.expected=Import selector expected
simple.type.expected.requires=Simple type expected in requires block
unreachable.error=Unexpected error found
val.var.expected=Val or var keyword expected
def.dcl.expected=Definition or declaration expected
type.dcl.expected=Type declaration expected
block.expected=Block expected
type.tale.expected=Type keyword expected im simple type tale
existential.block.expected=Existential clause expected
fun.sign.expected='=>' expected
pattern.expected=Pattern expected
compound.type.expected=Compound type expected
refined.type.expected=Refined type expected
condition.expected=Boolean condition expected
simple.pattern.expected=Illegal start of simple pattern
constr.block.expected=Constructor block expected
wrong.constr.expression=Wrong constructor expression
param.clause.expected=Parameter clause expected
this.expected='this' keyword expected
expr.expected=Expression expected
arg.expr.expected=Argument expression expected
implicit.params.excepted=Implicit parameter clause must have at least one parameter
wrong.type.associativity=Wrong associativity. All operators should have the same associativity
wrong.top.statment.declaration=Wrong top statement declaration
wrong.simple.type=Wrong simple type
xml.tag.end.expected=Xml tag end expected
xml.end.tag.expected=Xml end tag ('</' name '>') expected
xml.name.expected=Xml tag name expected
xml.scala.injection.end.expected=Scala injection end ('}') in xml expected
xml.scala.expression.exected=Scala expression expected in injection in xml
xml.PI.end.expected=Xml proccessing instructions end expected
xml.comment.end.expected=Xml comment end ('-->') expected
xml.wrong.character=Wrong character in xml comment
xml.cdata.end.expected=Xml CData end expected
xml.attribute.end.expected=Xml attribute value end delimiter expected
xml.eq.expected='=' expected
xml.attribute.value.expected=Attribute value expected
xml.scala.patterns.exected=Scala patterns expected in injection in xml
return.outside.method.definition=Return statement outside method definition
unbound.placeholder.parameter=Unbound placeholder parameter
local.variables.must.be.initialized=Local variables must be initialiazed

# TODO unify type mismatch messages
type.mismatch.message=Type mismatch. Required: {0}, found: {1}

type.mismatch.tooltip=\
  <html><body>Type mismatch.\
  <table>\
  <tr><td>Required:</td>{0}</tr>\
  <tr><td>Found:</td>{1}</tr>\
  </table>\
  </body></html>

# TODO unify type mismatch messages
expr.type.does.not.conform={0} type in expression doesn''t conform to value declared type
# TODO unify type mismatch messages
expr.type.does.not.conform.expected.type=Expression of type {0} doesn''t conform to expected type {1}
# TODO unify type mismatch messages
patt.type.does.not.conform.expr.type=Expected type for pattern {0} doesn''t conform to expression type {1}
type.takes.type.parameters=Type {0} takes type parameters
default.init.prohibited.literal.types=Default initialization prohibited for literal-typed vars

########################################################################################################################
# Building caches
########################################################################################################################
title.cache.updating=Updating caches
title.cache.creating=Creating caches
title.cache.files.scanning=Scanning files...
title.cache.files.parsing=Parsing new files...
title.please.wait=Please wait
title.cache.saving=Saving caches
title.cache.datafile.loading=Loading caches
title.cache.files.removing=Removing old caches
title.cache.loading=Loading caches

########################################################################################################################
# Error reports
########################################################################################################################
error.report.to.jetbrains.action=Report To Jetbrains
error.report.submit.label=<html>This error report will be created as new <b>JIRA</b> issue \
  <br><b>''{0}''</b><br>at \
  <b><a href="{1}{2}">{1}{2}</a></b> <br>as component <b>''{3}''</b>.\
  <br><br>Please provide a short description of the error and how can it be reproduced:</html>
error.report.submit.register.in.jira=<html><a href="{0}">Signup for an account</a></html>
error.report.submit.new.issue.url=<html>Your issue was successfully added, see<br>     <a href="{0}">{0}</a></html>
error.report.submit.new.issue.title=Issue Added
error.report.wrong.login=Invalid username or password.
error.report.canceled=Canceled sending report
error.report.error.creating.issue=Error creating new JIRA issue
error.report.jira.issue=JetScala issue #{0}
error.report.dialog.title=Submit Error
error.report.dialog.wrong.password.title=Sending Failed
error.report.button.sendreport.caption=&Send Report
error.report.button.cancel.caption=&Cancel
error.report.form.not.jira=&I do not have a JIRA account, create issue on behalf of 'JetScala error reporter'
error.report.form.jira=I'm a &JIRA user
error.report.form.jira.login=&Login
error.report.form.jira.password=&Password
error.report.form.jira.password.save=Save password
repetitive.method.name.signature=Repetitive method name/signature
repetitive.method.name.signature.and.return.type=repetitive method name, signature and return type
illegal.combination.of.modifiers=illegal combination of modifiers
modifier.is.not.allowed.here.0=modifier ''{0}'' is not allowed here
illegal.combination.of.modifiers.abstract.and.final=illegal combination of modifiers 'abstract' and 'final'
modifier.volatile.not.allowed.here=modifier 'volatile' not allowed here
modifier.transient.not.allowed.here=modifier 'transient' not allowed here
intarface.cannot.have.modifier.final=interface cannot have modifier 'final'
script.cannot.have.modifier.abstract=script cannot have modifier 'abstract'
script.cannot.have.modifier.native=script cannot have modifier 'native'
interface.must.have.no.static.method=interface must have no static method
not.abstract.class.cannot.have.abstract.method=not abstract class cannot have abstract method
illegal.combination.of.modifiers.volatile.and.final=illegal combination of modifiers 'volatile' and 'final'
variable.cannot.be.native=variable cannot have modifier 'native'
variable.cannot.be.abstract=variable cannot have modifier 'abstract'
not.abstract.class.cannot.have.method.without.body=not abstract class cannot have method without body
not.abstract.method.should.have.body=not abstract method should have body
cannot.create.class.error.text=Cannot Create Class ''{0}'': {1}
cannot.create.class.error.title=Cannot Create Class
no.class.in.file.template=No Class Found in File Template
interface.must.have.no.private.method=interface must have no private method
error.external=External error
Inner.methods.are.not.supported=Inner methods are not supported
final.class.cannot.be.extended=Final class cannot be extended
cannot.resolve=Cannot resolve symbol {0}
cannot.resolve.apply.method=Cannot resolve method {0}.apply
cannot.resolve.unapply.method=Cannot resolve method {0}.unapply
cannot.resolve.in.StringContext=Value ''{0}'' is not a member of StringContext
cannot.resolve.overloaded=Cannot resolve overloaded method ''{0}''
element.is.not.accessible=Element {0} has private access from this place
class.must.declared.abstract=Class ''{0}'' must be declared abstract or implement inherited abstract members
object.must.implement=Object ''{0}'' must implement not implemented methods
only.for.scala=This works only with scala files
cannot.refactor.no.function=Can't find function for introduce parameter
cannot.refactor.not.expression=Selected string cannot be extracted as expression
cannot.refactor.not.valid.type=Type element should be selected
cannot.refactor.not.expression.nor.type=Expression or type element should be selected
cannot.refactor.scope.not.found=No suitable class or package was found
cannot.refactor.constr.expression=Selected block shouldn't be presented as constructor expression
cannot.refactor.constructor.parameter.top.level=Refactoring is not supported for constructor parameters in top level classes
cannot.refactor.under.generic.call=Refactoring is not supported in generic calls
cannot.refactor.arg.in.self.invocation.of.constructor=Refactoring is not supported for arguments of self-invocation in the constructor body
cannot.refactor.named.arg=Refactoring is not supported for named arguments
cannot.refactor.literal.pattern=Refactoring is not supported for literal patterns
cannot.refactor.class.parameter.top.level=Refactoring is not supported for parameters of top level classes
cannot.refactor.interpolated.string.prefix=Refactoring is not supported for interpolated string prefix
cannot.refactor.self.invocation=Refactoring is not supported for the constructor call in auxiliary constructor
refactoring.is.not.supported.in.guard=Refactoring is not supported in guards, it most likely break code structure
wrong.refactoring.context=Refactoring is not supported in current context
operation.not.supported.in.current.block=Operation is not supported in current block
file.is.not.writable=File hasn't access to be writable
introduced.variable.will.conflict.with.local=Introduced variable conflicts with (or may be hidden by) local variable: {0}
introduced.variable.will.conflict.with.parameter=Introduced variable conflicts with (or may be hidden by) parameter: {0}
introduced.variable.will.conflict.with.field=Introduced variable will conflicts with (or may be hidden by) field or method \
  without parameters: {0}
introduced.typeAlias.will.conflict.with.type.name=Introduced type alias conflicts with type name: {0}
introduced.typeAlias.will.conflict.with.class.name=Introduced type alias conflicts with class name: {0}
introduced.variable.will.conflict.with.class.parameter=Introduced variable conflicts with (or may be hidden by) class parameter: {0}
class.import.title=Add import for class:
select.method.override=Select Members to Override
select.method.implement=Select Members to Implement
pull.method.to=Pull method ''{0}'' to...
pull.value.to=Pull value ''{0}'' to...
pull.variable.to=Pull variable ''{0}'' to...
wrong.declaration.in.block=Block cannot contain declarations
import.expr.should.be.qualified=Import expression must be qualified
cannot.extract.empty.message=Wrong selection for the refactoring. Number of complete expressions or statements expected.
cannot.extract.self.invocation=Cannot extract self invocation.
cannot.extract.used.function.definition=Refactoring is not supported: function definition inside selection is used outside of the selected fragment
cannot.extract.used.type.definition=Refactoring is not supported: type definition inside selection is used outside of the selected fragment
extract.method.cannot.find.possible.scope=Cannot find possible scope for extracted method
method.is.not.member=Method {0} is not a member of type {1}
expected.type.boolean=Expected type Boolean as method {0} return type
xml.no.opening.tag=No Opening Tag
xml.no.closing.tag=No Closing Tag
cannot.inline.different.files=Member is declared in the other file. Inline is not supported.
cannot.inline.used.outside.class=Member is used outside of the containing class. Inline is not supported.
cannot.inline.stable.reference=Value is used in a stable reference and cannot be inlined
cannot.inline.never.used=Variable is never used.
cannot.inline.not.simple.pattern=Inline is supported only for simple pattern definitions
cannot.inline.recursive.function=Inline is not supported for recursive functions
cannot.inline.function.implicit.parameters=Inline is not supported for functions with implicit parameters
cannot.inline.function.multiple.clauses=Inline is not supported for functions with several parameter clauses
cannot.inline.function.varargs=Inline is not supported for functions with varargs parameter
cannot.inline.implicit.element=Inline is not supported for implicit elements
cannot.inline.special.function=Inline is not supported for special functions
cannot.inline.generic.function=Inline is not supported for generic functions
cannot.inline.notsimple.typealias=Inline is supported only for simple type alias
cannot.inline.value.functional.type=Inline of values with functional types is not supported
cannot.inline.function.functional.parameters=Inline of functions with functional parameters is not supported
cannot.inline.parameter=Inline is not supported for parameters
cannot.inline.not.method.call=Inline is supported for regular method calls only
change.signature.vararg.should.be.last.in.clause=Vararg parameter should be the last in parameter clause
0.is.not.a.legal.scala.identifier=''{0}'' is not a legal scala identifier
library.sources.not.found=Sources not found
library.sources.not.attached=Sources not attached
########################################################################################################################
# FunctionAnnotator
########################################################################################################################
method.is.recursive=Method ''{0}'' is recursive
method.is.tail.recursive=Method ''{0}'' is tail recursive

function.must.define.type.explicitly=Method {0} has return statement; needs result type
function.recursive.need.result.type=Recursive method {0} needs result type
return.expression.is.redundant=Returning {0} from a method with Unit result type
cannot.have.implicit.parameters.and.implicit.bounds=Cannot have both implicit parameters and context bounds `: ...' or view bounds `<% ...' on type parameters

########################################################################################################################
# Annotator reports
########################################################################################################################
# TODO unify type mismatch messages
type.mismatch.found.required=Type mismatch, found: {0}, required: {1}
# TODO unify type mismatch messages
type.mismatch.expected.actual=Type mismatch, expected: {0}, actual: {1}
# TODO unify type mismatch messages
type.mismatch.default.args.expected.actual=Type mismatch involving default arguments, expected: {0}, actual: {1}
block.must.end.result.expression=Block must end in result expression
member.needs.override.modifier={0} ''{1}'' needs override modifier
illegal.cyclic.reference=Illegal cyclic reference ''{0}''
member.overrides.nothing={0} ''{1}'' overrides nothing
can.not.override.final={0} ''{1}'' cannot override final member
member.cannot.override.var=method {0} cannot override a mutable variable
member.cannot.override.val= method {0} needs to be a stable, immutable value
var.cannot.override.val= variable {0} cannot override immutable value
implements.method.from.super=Implements method in <a href="#javaClass/{0}">{0}</a>
overrides.method.from.super=Overrides method in <a href="#javaClass/{0}">{0}</a>
implements.val.from.super=Implements value in <a href="#javaClass/{0}">{0}</a>
overrides.val.from.super=Overrides value in <a href="#javaClass/{0}">{0}</a>
overrides.type.from.super=Overrides type in <a href="#javaClass/{0}">{0}</a>
multiple.overriding.tooltip=Multiple overriding members
multiple.overriden.tooltip=Multiple overriden members
navigation.title.super.methods=Choose Super Method of {0}
navigation.findUsages.title.super.methods=Super Methods of {0}
navigation.title.super.vals=Choose Super Member of {0}
navigation.findUsages.title.super.vals=Super Members of {0}
navigation.title.super.types=Choose Super Type Member of {0}
navigation.findUsages.title.super.types=Super Type Member of {0}
anonymous.class.must.declared.abstract=Anonymous class must implement inherited abstract members
trait.has.implementations=Trait has implementations
class.has.subclasses=Class has subclasses
navigation.title.inheritors.trait=<html>Choose Implementation of <b>{0}</b> ({1} classes found)</html>
navigation.findUsages.title.inheritors.trait=Implementations of {0}
navigation.title.inheritors.class=<html>Choose subclass of <b>{0}</b> ({1} classes found)</html>
navigation.findUsages.title.inheritors.class=Subclasses of {0}
has.implementations=Member has implementations
is.overridden.by=Member has overrides
navigation.title.implementing.member=<html>Choose Implementing Member of <b>{0}</b> ({1} members found)</html>
navigation.findUsages.title.implementing.member=Implementing Members of {0}
navigation.title.overriding.member=<html>Choose Overriding Member of <b>{0}</b> ({1} members found)</html>
navigation.findUsages.title.overriding.member=Overriding Members of {0}
goto.super.member.chooser.title=Choose supermember
goto.super.class.chooser.title=Choose superclass
goto.super.class.or.member.chooser.title=Choose superclass / supermember
cyclic.reference.type=Illegal cyclic reference involving type {0}
lazy.modifier.is.not.allowed.here='lazy' modifier allowed only with value definitions
lazy.modifier.is.not.allowed.with.param='lazy' modifier not allowed here, use call-by-name parameter instead
lazy.values.may.not.be.abstract=lazy values may not be abstract
final.modifier.not.with.declarations='final' modifier can't be used with incomplete members
final.modifier.not.with.trait='final' modifier not allowed with trait
final.modifier.is.redundant.with.object='final' modifier is redundant for toplevel objects
final.modifier.is.redundant.with.final.parents='final' modifier is redundant for objects or final class members
final.modifier.is.not.allowed.here='final' modifier is not allowed here
access.modifier.is.not.allowed.here=''{0}'' modifier is not allowed here
abstract.modifier.redundant.fot.traits='abstract' modifier is redundant for traits
abstract.modifier.is.not.allowed='abstract' modifier allowed only for classes or for definitions with 'override' modifier
abstract.override.modifier.is.not.allowed='abstract override' modifier only allowed for members of traits
override.modifier.is.not.allowed.for.classes='override' modifier allowed only for type definitions members
override.modifier.is.not.allowed='override' modifier is not allowed here
sealed.modifier.is.not.allowed.here='sealed' modifier is not allowed here
illegal.modifiers.combination=Illegal modifiers combination: {0} and {1}
id.is.already.defined={0} is already defined in the scope
implicit.usage.tooltip=<html>\
  <body>\
  Implicit conversion {0}(<b>{1}</b>): <b>{2}</b> detected
  </body>\
  </html>
implicit.usage.message=Implicit conversion ''{0}({1}): {2}'' detected.
val.on.case.class.param.redundant='val' modifier is redundant for parameter of case class primary constructor
new.on.case.class.instantiation.redundant=remove 'new' modifier
suspicicious.inference=Inferred type of {0} is suspicious. If you really want this, explicitly annotate the type.
suspicicious.newline=Newline before argument list is not inferred as a semicolon. Consider using '.' before the method name.
constructor.invocation.expected='this' expected
called.constructor.definition.must.precede=Called constructor's definition must precede calling constructor's definition
scala.mutable.collection=Mutable Collection
scala.immutable.collection=Immutable Collection
java.collection=Java Collection
pattern.on.refinement.unchecked=a pattern match on a refinement type is unchecked
type.cannot.be.used.in.type.pattern=type {0} cannot be used in a type pattern or isInstanceOf test
scrutinee.incompatible.pattern.type=Scrutinee is incompatible with pattern type, found: {0}, required: {1}
pattern.type.incompatible.with.expected=Pattern type is incompatible with expected type, found: {0}, required: {1}
constructor.cannot.be.instantiated.to.expected.type=Constructor cannot be instantiated to expected type, found: {0}, required: {1}
fruitless.type.test=fruitless type test: a value of type {0} cannot also be a {1}
erasure.warning= (but still might match its erasure)
wrong.number.arguments.extractor=Wrong number of arguments for extractor, found: {0}, expected: {1}
wrong.number.arguments.extractor.unapplySeq=Wrong number of arguments for extractor, found: {0}, expected: {1} or more
stable.identifier.required=Stable identifier required but {0} found
covariant.type.contravariant.position.of.method=Covariant type {0} occurs in contravariant position in type {1} of method {2}
covariant.type.contravariant.position.of.value=Covariant type {0} occurs in contravariant position in type {1} of value {2}
covariant.type.invariant.position.of.method=Covariant type {0} occurs in invariant position in type {1} of method {2}
covariant.type.invariant.position.of.value=Covariant type {0} occurs in invariant position in type {1} of value {2}
contravariant.type.covariant.position.of.method=Contravariant type {0} occurs in covariant position in type {1} of method {2}
contravariant.type.covariant.position.of.value=Contravariant type {0} occurs in covariant position in type {1} of value {2}
contravariant.type.invariant.position.of.method=Contravariant type {0} occurs in invariant position in type {1} of method {2}
contravariant.type.invariant.position.of.value=Contravariant type {0} occurs in invariant position in type {1} of value {2}
abstract.member.not.have.private.modifier=Abstract member may not have private modifier
# TODO Remove? (or even better, do show a clarification, just as the scalac does)
missing.arguments.for.method=Missing arguments for method {0} and is not a partially applied function. Add more arguments or insert a placeholder.
lower.bound.conform.to.upper=Lower bound doesn't conform to upper bound
illegal.secondary.constructors.value.class=Secondary constructors are not allowed in value classes
value.class.can.have.only.one.parameter=Value classes can have only one parameter
value.class.can.have.only.val.parameter=Value classes can have only one non-private val parameter
type.parameter.value.class.may.not.be.specialized=Type parameter of value class may not be specialized
value.classes.cannot.have.nested.objects=Value classes cannot have nested classes, objects or traits
value.classes.cannot.redefine.equals.hashcode=Value classes cannot redefine equals and hashCode
value.classes.can.have.only.defs=Field definitions are not allowed in value classes
illegal.inheritance.from.final.kind=Illegal inheritance from final {0} ''{1}''
illegal.inheritance.from.value.class=Illegal inheritance from value class ''{0}''
illegal.inheritance.from.sealed.kind=Illegal inheritance from sealed {0} ''{1}''
illegal.inheritance.multiple={0} ''{1}'' inherited multiple times
illegal.inheritance.self.type=Illegal inheritance, self-type {0} does not conform to {1}
illegal.mixin={0} ''{1}'' needs to be trait to be mixed in
illegal.instantiation={0} ''{1}'' is abstract; cannot be instantiated
member.implementation.required={0} ''{1}'' must either be declared abstract or implement abstract member ''{2}'' in ''{3}''
mixin.required={0} ''{1}'' needs to be mixin, since member ''{2}'' in ''{3}'' is marked 'abstract' and 'override', but no concrete implementation could be found in a base class
illegal.undefined.member=Only classes can have declared but undefined members
value.classes.may.not.be.member.of.another.class=Value class may not be member of another class
string.literal.is.too.long=String literal size exceeds compiler limit
numeric.literal.family=Numeric literals
octal.literals.removed=Octal literals syntax has been disabled since Scala 2.11
octal.literals.deprecated=Octal literals syntax has been deprecated in Scala 2.10
convert.to.hex.fix=Convert octal literal to hex
trailing.underscore.separator=Trailing underscore separator is not allowed
illegal.underscore.separator=Underscore separators require Scala 2.13
for.pattern.bindings.require.scala3='case' syntax in 'for' pattern bindings requires Scala 3.0
annotation.ascriptions.in.pattern.definitions.require.scala3=annotation ascriptions in pattern definitions require Scala 3.0
vararg.pattern.with.colon.requires.scala3=':' syntax in vararg pattern requires Scala 3.0
vararg.pattern.with.at.deprecated.since.scala3='@' syntax in vararg pattern has been deprecated since Scala 3.0
vararg.short.pattern.with.at.deprecated.since.scala3=Short _* pattern syntax has been deprecated since Scala 3.0
vararg.pattern.must.be.last.pattern=_* can be used only for last argument
long.literal.is.out.of.range=Integer number is out of range even for type Long
integer.literal.is.out.of.range=Integer literal is out of range for type Int
convert.to.long.fix=Convert to long literal
lowercase.long.marker=Lower cased long literal marker
lowercase.long.marker.fix=Convert long literal marker to upper case
override.types.not.conforming=Overriding type {0} does not conform to base type {1}
better.monadic.for.invalid.pattern=Argument must have explicit type annotation
repeated.param.non.method=Repeated parameters are only allowed in method signatures. Use `Seq` instead
macro.defs.must.have.explicit.return.type=Macro defs must have explicitly specified return types
trait.parameter.require.scala3=Trait parameters require Scala 3.0
########################################################################################################################
# Scala actions
########################################################################################################################
import.with=Import ''{0}''
import.class=Import class
import.package=Import package
import.something=Import ...
import.class.chooser.title=Class to Import
import.package.chooser.title=Package to Import
import.something.chooser.title=Name to Import
import.implicitInstance.chooser.title=Select implicit instance to import
report.highlighting.error.fix=Report highlighting error...
implement.methods.fix=Implement methods
add.modifier.fix=Add ''{0}'' modifier
remove.modifier.fix=Remove ''{0}'' modifier
make.non.private.title=Make property non-private
make.protected.fix=Make property protected
make.public.fix=Make property public
specify.return.type.explicitly=Specify &type
add.override.modifier=Insert "&override"
copy.scaladoc=Copy &ScalaDoc
element.of.trait=of trait
element.of.class=of class
element.method=method
label.method=Method {0}
find.usages.compiler.indices.dialog.title=Find Usages ({0})
find.usages.member.has.supers= Member {0} overrides/implements some base member.\n\
  Do you want to find usages for the base member?
method.has.supers= Method {0} overrides/implements some base method, rename it as well?
remove.explicit.val=Remove explicit 'val'
xml.delete.unmatched.tag=Delete Unmatched Tag
xml.rename.opening.tag=Rename Opening Tag
xml.rename.closing.tag=Rename Closing Tag
create.scaladoc.stub.action=Create ScalaDoc stub action
wrap.in.option.name=Wrap in Option
wrap.in.option.hint=Wrap expression in Option(...)?
convert.java.to.scala.collection.hint=Convert to Scala collection using asScala?
convert.java.to.scala.collection.name=Convert to Scala collection
convert.scala.to.java.collection.hint=Convert to Java collection using asJava?
convert.scala.to.java.collection.name=Convert to Java collection
choose.expression.for=Choose Expression for {0}
choose.type.element.for=Choose Type Element for {0}
choose.scope.for=Choose Scope for {0}
rename.companion.module=Rename companion {0}

unwrap.case.clause=Unwrap case clause
remove.case.clause=Remove case clause
unwrap.try.with.finally=Unwrap try / finally
unwrap.finally=Unwrap finally
remove.finally=Remove finally block
remove.catch=Remove catch block
unwrap.interpolated.string.injection=Unwrap interpolated string injection
convert.to.explicit.symbol=Convert to Symbol("{0}")
convert.to.explicit.symbol.family=Convert to explicit Symbol
module.libraries.attach.sources.immediately.button=Attach sources...
########################################################################################################################
# Scala facet
########################################################################################################################
maven.repository.presentable.name=Maven repository
config.display.name=Configuration
scala.facet.title=Sca&la
config.scala.libraries=Configure Scala libraries

scala.config.label=Scala installation directory
scala.config.dscr=Please specify path to Scala installation directory
scala.config.noscala.title=Scala Configuration Error
scala.config.download.link=https://www.scala-lang.org/downloads/
scala.config.download.link.label=Scala is available for download on:
scala.config.compiler.library=Scala comp&iler library:
scala.config.sdk.library=Scala &SDK library:
scala.config.sdk.space.hint=Several paths must be separated by file separator - '';''
scala.config.take.compiler.from.settings=Use Scala compiler &libraries from specified jars
scala.config.take.relative.path=Use relative path towards the project root
error.scala.path.not.valid=Scala path is not valid

scala.compiler.profiles.panel.profile.name=Profile Name
scala.compiler.profiles.panel.move.to=Move To
scala.compiler.profiles.panel.create.new.profile=Create New Profile
scala.compiler.profiles.panel.profile.should.not.be.empty=Profile name shouldn't be empty
scala.compiler.profiles.panel.profile.already.exists=Profile {0} already exists

scala.config.project.template.name=Non-sbt
scala.config.project.template.description=Module for developing Scala Application
scala.config.project.settings.title=Scala Settings
scala.config.module.name=Scala Module
scala.config.module.description=Create Scala Module

##########################################################################################################################
# SDK & compilation
########################################################################################################################

no.java.sdk=No java SDK configured
cannot.compile.scala.files.no.facet=Please attach a Scala facet to module.
cannot.compile.scala.files.no.compiler=Please, specify compiler library in Scala facet.
cannot.compile.scala.files.compiler.problem=Please, adjust compiler library in Scala facet: {0}.
cannot.compile.scala.files.no.sdk=Please, set up Java SDK for module ''{0}''.
cannot.compile.scala.files.no.sdk.mult=Please, Set up Java SDK for modules ''{0}''.
cannot.compile=Cannot compile Scala files
debug.option=Enable debug stacktrace
scalac.compiler.name=Scalac
javac.error.tools.jar.missing=Cannot obtain path javac classes for JDK {0}.\nUpdate JDK configuration.
javac.error.unknown.jdk.version=Cannot determine version for JDK {0}.\nUpdate JDK configuration.
different.scala.sdk.in.modules=Dependent modules must have equal Scala SDK versions
scala.compiler.description=Scala compiler
scala.debug.disable.specific.methods=Do not step &into specific Scala classes
scala.debug.caption=Scala
jtype.is.not.found=Cannot compile Scala files.\nch.epfl.lamp.fjbg.JType class is not found. \nPlease, attach appropriate jar to the module ''{0}''.

########################################################################################################################
# Facet configuration
########################################################################################################################
scala.sdk.configuration=Scala SDK configuration
new.button.label=New
scala.sdk.configuration.label=<html><b>Scala SDK:</b><br>Choose Scala SDK specific for this module</html>
add.new.scala.lib=New Scala SDK
invalid.scala.sdk.path.text=Wrong path specified
duplicate.scala.lib.version=Duplicated Scala SDK version
duplicate.scala.lib.version.add=Add one more Scala SDK of version {0}?
scala.sdk.combo.box.project.item=<No Scala SDK>
no.scala.facet=Scala Facet expected
new.scala.facet.detected=Scala Facet detected
invalid.scala.sdk.path.message=Invalid path to Scala SDK
introduce.variable.title=Introduce Value / Variable
introduce.type.alias.title=Introduce Type Alias
introduce.parameter.title=Introduce Parameter
introduce.field.title=Extract Field
extract.method.title=Extract Method
extract.local.method=Extract local method in {0}
press.escape.to.remove.the.highlighting=Press escape to remove the highlighting
facet.create.lib.title=Create Scala library
facet.create.project.lib=Create &Project-level Scala library ''{0}''
facet.create.application.lib=Create &Application-level Scala library ''{0}''

facet.setting.exclude.compiler.from.cp=Exclude Scala Com&piler library from module scope
facet.setting.exclude.library.from.cp=Exclude Scala SDK &library from module scope

########################################################################################################################
# File Templates
########################################################################################################################
file.template.group.title.scala=Scala

# class
newclass.dlg.prompt=Enter name for new Scala Class
newclass.dlg.title=New Scala Class
newclass.menu.action.text=Scala Class
newclass.menu.action.description=Creates new Scala Class
newclass.command.name=Create Scala Class
newclass.progress.text=Creating Scala Class ''{0}''
# worksheet
newworksheet.dlg.prompt=Enter name for new Scala Worksheet
newworksheet.dlg.title=New Scala Worksheet
newworksheet.menu.action.text=Scala Worksheet
newworksheet.menu.action.description=Creates new Scala Worksheet
newworksheet.command.name=Create Scala Worksheet
newworksheet.progress.text=Creating Scala Worksheet ''{0}''
#object
newobject.dlg.prompt=Enter name for new Scala object
newobject.dlg.title=New Scala Object
newobject.menu.action.text=Scala Object
newobject.menu.action.description=Creates new Scala Object
newobject.command.name=Create Scala Object
newobject.progress.text=Creating Scala Object ''{0}''
#trait
newtrait.dlg.prompt=Enter name for new Scala Trait
newtrait.dlg.title=New Scala Trait
newtrait.menu.action.text=Scala Trait
newtrait.menu.action.description=Creates new Scala Trait
newtrait.command.name=Create Scala Trait
newtrait.progress.text=Creating Scala Trait ''{0}''

scala.compiler.option.additional.command.line.parameters=Scala compiler additional command line parameters

########################################################################################################################
# Decompiler output
########################################################################################################################
psi.decompiled.text.header=\
  // IntelliJ API decompiler for Scala language\n\
  // Stub source generated from a class file\n\
  // Implementation of functions is not available

########################################################################################################################
# Scala compiler settings
########################################################################################################################
scala.compiler.heap.size=Maximum heap size (MB):
scala.compiler.cmd.line.params=Command line parameters
scala.compiler.use.deprecation=Compile @&deprecated annotations
scala.compiler.scalac.first=Compile &Scala files first
scala.compiler.show.unchecked=Compile @&unchecked annotations
scala.compiler.generate.no.warnings=Generate no &warnings
scala.compiler.optimize=&Optimise bytecode
scala.compiler.no.generics=Suppress Scala &generic signatures

########################################################################################################################
# Scala Type checked error messages
########################################################################################################################
no.right.operand.found=No right operand found
cannot.resolve.infix.operator=Cannot resolve infix operator
circular.dependency.detected=Circular dependency detected for the type alias ''{0}''
no.type.inferred=No type inferred for the expression ''{0}''
no.type.element.found=No type element found in ''{0}''
nothing.to.type=Nothing to type
no.result.expression.found=No result expression found
wrong.type.no.literal.types=Wrong type `{0}`, for literal types support use Scala 2.13 or Typelevel Scala with `-Yliteral-types` compiler flag
wrong.psi.for.literal.type="Wrong element to get Literal type"

########################################################################################################################
# Scala control flow errors
########################################################################################################################
unreachable.expression=Unreachable statement

########################################################################################################################
# Scala type info
########################################################################################################################
type.info=Type Info

########################################################################################################################
# Scala intentions
########################################################################################################################

intention.type.annotation.toggle.family=Toggle Type Annotation
intention.add.explicit.unit.type.annotation=Add explicit Unit Type Annotation

intention.type.annotation.regen.family=Regenerate Type Annotation

intention.type.annotation.function.add.text=Add type annotation to function definition
intention.type.annotation.function.remove.text=Remove type annotation from function definition
intention.type.annotation.function.regenerate.text=Regenerate type annotation for function definition

intention.type.annotation.value.add.text=Add type annotation to value definition
intention.type.annotation.value.remove.text=Remove type annotation from value definition
intention.type.annotation.value.regenerate.text=Regenerate type annotation for value definition

intention.type.annotation.variable.add.text=Add type annotation to variable definition
intention.type.annotation.variable.remove.text=Remove type annotation from variable definition
intention.type.annotation.variable.regenerate.text=Regenerate type annotation for variable definition

intention.type.annotation.pattern.add.text=Add type annotation to pattern definition
intention.type.annotation.pattern.remove.text=Remove type annotation from pattern definition

intention.type.annotation.parameter.add.text=Add type annotation to parameter
intention.type.annotation.parameter.remove.text=Remove type annotation from parameter

intention.type.annotation.underscore.add.text=Add type annotation to underscore parameter
intention.type.annotation.underscore.remove.text=Remove type annotation from underscore parameter

make.type.more.specific.fun=Make return type more specific
make.type.more.specific=Make declared type more specific

intention.for.comprehension.convert.to.parentheses=Convert to parentheses

choose.inferred.or.super.type.popup.title=Select Type

########################################################################################################################
# Scala test runner display name patterns
########################################################################################################################
test.in.scope.specs.presentable.text=Specs in ''{0}''
test.in.scope.specs2.presentable.text=Specs2 in ''{0}''
test.in.scope.scalatest.presentable.text=ScalaTests in ''{0}''
test.in.scope.utest.presentable.text=UTests in ''{0}''

########################################################################################################################
# Scala code inspections
########################################################################################################################
equals.between.inconvertible.types.display.name=Equality test between objects of inconvertible types
equals.between.inconvertible.types.description=Detects equality tests that will always return false, because the static type of the operands are inconvertible.
equals.between.inconvertible.types.problem.descriptor=Equality test between objects of inconvertible types ''{0}'' and ''{1}'' #loc
replace.tuple.type=Replace TupleN[A1, A1, ...,  AN] with (A1, A1, ...,  AN)
replace.fun.type=Replace FunctionN[A1, A1, ...,  AN, R] with (A1, A1, ...,  AN) => R
make.import.fully.qualified=Make import fully qualified
remove.braces.from.import=Remove braces from import statement
remove.return.keyword=Remove return keyword
remove.val=Remove 'val'
convert.var.to.val=Convert 'var' to 'val'
specify.type.of.exception=Specify type of exception
delete.inlined.tag=Delete Inlined Tag
replace.with.wiki.syntax=Replace inlined tag with monospace wiki syntax
move.text.after.header.to.new.line=Move text after header closing to new line
balance.header=Balance Header
replace.tag.with.esc.seq=Replace tag with escape sequence
delete.duplicating.param=Delete duplicating parameter
delete.tag=Delete tag
delete.unknown.tag=Delete Unknown Tag
semicolon.not.allowed.here=Semicolon not allowed here
remove.all.erroneous.semicolons.from.forexpression=Remove all erroneous semicolons from for expression
########################################################################################################################
# Scala project options
########################################################################################################################
collection.type.highlighting.option=Collection type highlighting:
enumerators.binding.val.keyword.deprecated='val' keyword in enumerators is deprecated
enumerators.binding.case.keyword.found=Expected pattern, but 'case' was found
enumerators.generator.val.keyword.found=Expected pattern, but 'val' was found
friendly.collection.debug.start.index=Collection start index
friendly.collection.debug.end.index=Collection end index
friendly.collection.display.enabled=Friendly display of Scala collections in debugger
friendly.collection.do.not.display.streams=Do not expand Streams and Views
dont.show.runtime.refs=Do not show runtime refs in debugger
force.class.prepare.request.for.nested.types=Force processing nested classes when they are loaded by VM
force.position.lookup.in.nested.types=Force creating breakpoints in nested types
show.variables.from.outer.scopes.in.variables.view=Show variables from outer scopes in variables view
move.to.inner.is.not.supported.title=Refactoring is not supported
move.to.inner.is.not.supported=Move class to inner is not supported for Scala
move.with.companion=Move together with the companion
insert.pair.multiline.quotes=Insert pair quotes for multiline string
wrap.single.expression.body=Wrap single expression body with closing brace after typing '{'
upgrade.to.interpolated=Upgrade simple string into interpolated after typing ${
symbolliterals.are.deprecated=Symbol literals are deprecated in Scala 2.13. Use Symbol("{0}") instead.
project.settings.sbt.index.ivy2.mode=Local ivy2 cache indexing mode
project.settings.sbt.index.ivy2.mode.hint=Disabled - no indexing done at all\nMetadata - only index library names and versions, used in SBT file dependency completion\nClasses - also index class names in cache, used by "Add sbt dependency" quickfix
#TODO: move to a worksheet section
########################################################################################################################
# Worksheet buttons
########################################################################################################################
worksheet.execute.button=Evaluate worksheet
worksheet.clear.button=Clear results
worksheet.copy.button=Copy worksheet
worksheet.stop.button=Stop worksheet execution
worksheet.settings.button=Show worksheet settings
worksheet.show.compiler.profiles.settings=Show compiler profiles settings
find.usages.implementing.type.definition=Implementing Type Definitions
find.usages.companin.module=Companion module usages
find.usages.instances.title=Instance Creation
find.what.members.usages.checkbox=Usages of &members
find.what.implementing.type.definitions.checkbox=Implementing type &definitions
find.what.companion.module.checkbox=Usages of &companion module
find.what.new.instances.usages=&Instance creation only
forward.reference.detected=Wrong forward reference
suspicicious.forward.reference.template.body=Suspicious forward reference in class

########################################################################################################################
# Refactorings
########################################################################################################################
introduce.variable.declare.as.var=&Variable
introduce.variable.specify.type.explicitly=Specify type
introduce.variable.identifier.is.not.valid=Identifier is not valid
introduce.typealias.search.companion=Raplace from companion
introduce.typealias.search.inheritors=Replace in inheritors
rename.special.method.title=This method can not be renamed
rename.special.method.rename.class=Rename containing {0}
rename.cancel=Cancel
rename.aliased.title=Renaming of import aliases is not supported
rename.aliased.rename.actual=Rename actual element
rename.getters.and.setters.title=Function has getters or setters with same name. Rename them as well?
introduce.field.choose.class=Choose class for Introduce Field
rename.all.base.members=Rename all base members
rename.base.member=Rename base member
rename.only.current.member=Rename only current member
rename.has.multiple.base.members={0} has multiple base members
rename.only.in=Rename only in {0} {1}
extract.trait.title=Extract trait
extract.trait.name.not.specified=No trait name specified
extract.trait.top.label.text=Extract trait from:
extract.trait.name=Trait name:
extract.trait.package.label=Package for new trait:
private.member.cannot.be.used.in.extracted.member=Private member {0} cannot be used in the extracted member {1}
member.of.anonymous.class.cannot.be.used.in.extracted.member=Member {0} of an anonymous class cannot be used in the extracted member {1}
super.reference.used.in.extracted.member=Extracted member {0} has reference to super, but extracted trait will not have a base class
type.parameters.for.self.type.not.supported=Extracted trait will have {0} as a self type, but identification of it's type parameters is not supported
members.to.extract=Members to extract
extract.abstracts=extract abstracts
target.0.already.contains.definition.of.1=<b>{0}</b> already contains definition of member <b>{1}</b>

error.wrong.caret.position.method.name=The caret should be positioned at the name of the method to be refactored.
change.signature.not.supported.multiple.parameter.clauses=Change signature is not supported for functions with multiple parameter clauses
change.signature.not.supported.constructors=Change signature in scala is not supported for constructors
change.signature.not.supported.implicit.functions=Change signature is not supported for implicit functions
change.signature.not.supported.implicit.parameters=Change signature is not supported for functions with implicit parameters
change.signature.not.supported.extractors=Change signature is not supported for extractors
change.signature.parameters.same.name.{0}=Parameters have same name: {0}
change.signature.specify.type.for.parameter=Specify type for parameter ''{0}''
default.ta.settings = Settings
default.ta.tooltip = Configure type annotation settings
move.members.object.name.or.qualified.name.expected=Name or qualified name of scala object expected
move.members.cannot.find.object=Cannot find object with such name
move.members.source.title=Move member from object:
move.members.target.title=To object:
move.members.supported.only.stable.objects=Move refactoring is supported only for stable object members
move.members.not.supported.implicits=Move refactoring is not supported for implicit definitions
move.members.not.supported.overridden=Move refactoring is not supported for overridden definitions
########################################################################################################################
# Debugger
########################################################################################################################
line.breakpoints.tab.title=Scala Line Breakpoints

########################################################################################################################
# Evaluation exception messages
########################################################################################################################
cannot.evaluate.imported.reference=Cannot evaluate imported reference
cannot.evaluate.local.method=Cannot evaluate local method
cannot.evaluate.parameter=Cannot evaluate parameter {0}
cannot.evaluate.method=Cannot evaluate method {0}
cannot.evaluate.local.object=Cannot evaluate local object {0}
cannot.evaluate.local.variable=Cannot evaluate local variable {0}
cannot.resolve.reference=Cannot resolve reference {0}
outer.this.not.available=Outer `this` is not available
wrong.number.of.arguments=Wrong number of arguments for method {0}
array.instance.is.not.found=Cannot evaluate method {0}: array instance is not found
array.method.not.supported=Array method not supported
cannot.find.implicit.parameters=Cannot find implicit parameters to pass
implicit.parameters.from.dependent.objects=Implicit parameters from dependent objects are not supported
implicit.conversions.from.dependent.objects=Implicit conversions from dependent objects are not supported
parameter.not.from.function=Evaluation from parameter not from function definition or function expression
method.with.by-name.parameters=Cannot evaluate methods with by-name parameters
wrong.number.of.expressions=Cannot evaluate arguments: wrong number of matched expressions
tupling.not.supported=Tupling is not supported. Use tuple expression.
not.used.from.for.statement=Cannot evaluate variable {0} from a for-statement because it was not used in the body
local.variable.from.anonymous.class=Cannot load local variable {0} from anonymous class
cannot.find.pattern=Cannot find pattern of case clause
cannot.find.expression.of.match=Cannot find expression of match statement
invalid.case.clause=Invalid case clause
assignent.without.expression=Cannot evaluate assign statement without expression
unapply.without.arguments=Cannot extract value from unapply without arguments
pattern.doesnot.resolves.to.unapply=Pattern reference {0} does not resolve to unapply or unapplySeq
pattern.alternatives.cannot.bind.vars=Pattern alternatives cannot bind variables
xml.patterns.not.supported=Xml patterns are not supported
kind.of.patterns.not.supported=This kind of patterns is not supported: {0}
anon.classes.not.supported=Anonymous classes are not supported
new.expression.without.class.reference=Cannot evaluate new expression without class reference
new.expression.without.constructor.call=Cannot evaluate expression without constructor call
new.expression.without.template.parents=Cannot evaluate expression without template parents
could.not.resolve.constructor=Could not resolve constructor
non-scala.code.fragment=Non-scala code fragment in scala evaluator builder
invalid.expression.in.parentheses=Invalid expression in parentheses: {0}
if.statement.without.condition=Cannot evaluate if statement without condition
if.statement.without.if.branch=Cannot evaluate if statement without if branch
formatted.interpolator.not.supported=Formatted string interpolator f"..." is not supported in scala 2.11
while.statement.without.condition=Cannot evaluate while statement without condition
while.statement.without.body=Cannot evaluate while statement without body
do.statement.without.condition=Cannot evaluate do statement without condition
do.statement.without.body=Cannot evaluate do statement without body
method.call.implicitly.converted.qualifier=Cannot evaluate method call with implicitly converted qualifier: {0}

########################################################################################################################
# Gradle project data service messages
########################################################################################################################
gradle.dataService.scalaVersionCantBeDetected=Cannot determine Scala compiler version for module {0}
gradle.dataService.scalaLibraryIsNotFound=Cannot find project Scala library {0} for module {1}

########################################################################################################################
# scala.meta messages
########################################################################################################################
scala.meta.recompile=Metaprogram is out of date. Click here to compile
scala.meta.expand=Expand macro
scala.meta.expandfailed=Macro expansion failed: {0}
scala.meta.settings.annot212=Execution of scala.meta programs
scala.meta.settings.annot212Tooltip=Due to binary incompatibility, annotations in 2.12 modules have to use\\  very slow string-based serialization and reparsing. This may seriously affect overall performance.
scala.meta.settings.modeOptionsTooltip=Enabled - all metaprograms are executed during type inference\nDisabled - \\  metaprograms are skipped during type inference\nManual - metaprograms run only when manually expanded
scala.meta.settings.trimBodiesCap=Trim method bodies expanded by scala.meta
scala.meta.settings.trimBodiesTooltip=Rely on explicit return types of generated methods(bodies are replaced with ???). Speeds up type inference by skipping method body typechecking.

########################################################################################################################
# Compiler indices settings UI
########################################################################################################################
scala.compiler.indices.settings.enable.cb=&Index .class files
scala.compiler.indices.settings.invalidate.button=&Delete indices
scala.compiler.indices.settings.navigate=Navigate to bytecode indices settings
scala.compiler.indices.progress.title=Indexing recompiled classfiles ...
scala.compiler.indices.sbt.automatic=&Automatic (requires sbt shell)
scala.compiler.indices.sbt.manual=&Manual
scala.compiler.indices.sbt.keys.text=ideaPort in Global :=
scala.compiler.indices.sbt.plugin.text=addSbtPlugin("org.jetbrains" % "sbt-idea-compiler-indices" % "{0}")
scala.compiler.indices.restart.required.title=Bytecode Indices Settings Update
scala.compiler.indices.restart.required.message={0} IDEA to activate changes in bytecode indices settings?

########################################################################################################################
# Type-aware highlighting
########################################################################################################################
configure.type.aware.highlighting=Configure type-aware highlighting for the project
type.aware.highlighting.title=Scala type-aware highlighting
click.or.press.shortcut.to.change=(click or press {0} to change)
click.to.change=(click to change)
enabled.word=enabled
disabled.word=disabled

#ScalaCompileServer UI
jvm.options=JVM &options:
jvm.maximum.heap.size.mb=JVM maximum &heap size, MB:
jdk=&JDK:
advanced.settings=Advanced settings
minutes=minutes
compile.server.new.project.restart=Compile server will be restarted on each compilation of a new project.
compile.server.use.project.home=Use project home as compile server &working directory
compile.server.jvm.command.line.parameters=Compile server JVM command line parameters
compile.server.shutdown.if.idle.for=Shutdown server if it is idle for
compile.server.description=The compile server is application-wide (there is a single instance for all projects).\nThe JDK is used to instantiate the compile server and to invoke \nan in-process Java compiler (when JDK and module SDK match).
compile.server.use.for.scala=Use compile &server for Scala
vm.options=VM options:
console.arguments=Console arguments:
working.directory=Working directory:
use.classpath.and.sdk.of.module=Use classpath and SDK of module:

#Scala compiler settings UI
incrementality.type=&Incrementality type:
unchecked.warnings=&Unchecked warnings
unchecked.warnings.tooltip=Enable additional warnings where generated code depends on assumptions.
deprecation.warnings=&Deprecation warnings
deprecation.warnings.tooltip=Emit warning and location for usages of deprecated APIs.
feature.dynamics=&Dynamics
feature.existential.types=&Existential types
explain.type.errors=&Explain type errors
explain.type.errors.tooltip=Explain type errors in more detail
feature.warnings=&Feature warnings
feature.warnings.tooltip=Emit language feature warnings.
feature.higher.kinded.types=&Higher-kinded types
feature.implicit.conversions=&Implicit conversions
feature.macros=&Macros
optimise.bytecode=&Optimise bytecode (use with care*)
optimise.bytecode.tooltip=Generates faster bytecode by applying optimisations to the program. May trigger various compilation problems. Use with care.
feature.postfix.notation=&Postfix operator notation
feature.reflective.calls=&Reflective calls
additional.compiler.options=Additional compiler &options:
compile.order=Compile &order:
compiler.plugins=Compiler plugins
debugging.info.level=Debugging info &level:
feature.experimental.features=E&xperimental Features
enable.continuations=Enable &continuations
enable.specialization=Enable &specialization
enable.specialization.tooltip=Respect @specialize annotations
enable.warnings=Enable &warnings
enable.warnings.tooltip=Generate warnings
features=Features
options=Options

#Bytecode indices settings
apply.unapply.methods=apply / unapply methods
for.comprehension.methods=For-comprehension methods (map, withFilter, flatMap, foreach)
add.line.to.build.sbt=Add the following line to build.sbt:
add.line.to.plugins.sbt=Add the following line to project/plugins.sbt:
implicit.definitions=Implicit definitions
port.number=Port number:
sam.types=SAM types
sbt.compilation.listener=sbt compilation listener configuration (application-wide)
use.indices.to.search=Use indices to search for usages of:

# TODO: extract to ScalaCodeStyleBundle.properties
########################################################################################################################
# Code style
########################################################################################################################

code.style.settings.scala.title=Scala

#Spaces
spaces.panel.simple.one.line.block.braces=Simple one line block braces
spaces.panel.import.braces=Import braces
spaces.panel.self.type.braces=Self type braces
spaces.panel.before.context.bound.colon.rest=Before context bound colon (rest)
spaces.panel.before.context.bound.colon.leading.higher.kinded=Before context bound colon (leading higher-kinded)
spaces.panel.before.context.bound.colon.leading=Before context bound colon (leading)
spaces.panel.before.opening.square.bracket=Before opening square bracket
spaces.panel.keep.one.line.comments.on.same.line=Keep one-line comments on same line
spaces.panel.newline.after.annotations=Newline after annotations
spaces.panel.around.at.in.pattern.bindings=Around '@' in pattern bindings
spaces.panel.inside.closure.braces=Inside closure braces
spaces.panel.before.colon.after.declarations.name=Before colon, after declarations' name
spaces.panel.after.colon.before.declarations.type=After colon, before declarations' type
spaces.panel.method.call.left.brace=Method call left brace
spaces.panel.preserve.space.before.method.parentheses=Preserve space before method parentheses
spaces.panel.infix.method.parentheses=Infix method parentheses
spaces.panel.infix.operator.like.method.call.parentheses=Infix operator-like method call parentheses
spaces.panel.infix.method.call.parentheses=Infix method call parentheses
spaces.panel.constructor.parameters.with.modifiers=Constructor parameters with modifiers

#Wrapping and Braces
#custom groups
wrapping.and.braces.panel.groups.method.definition=Method definition
wrapping.and.braces.panel.groups.anonymous.method.definition=Anonymous method definition
wrapping.and.braces.panel.groups.class.definition=Class definition
wrapping.and.braces.panel.groups.xml.formatting=Xml formatting
wrapping.and.braces.panel.groups.tuple=Tuple
wrapping.and.braces.panel.groups.type.arguments=Type Arguments
wrapping.and.braces.panel.groups.type.parameters=Type Parameters
#align options
wrapping.and.braces.panel.extends.do.not.align=Do not align
wrapping.and.braces.panel.extends.on.first.token=On first token
wrapping.and.braces.panel.extends.align.to.extends=Align to 'extends'
wrapping.and.braces.panel.force.braces=Force braces
wrapping.and.braces.panel.force.try.braces=Force 'try' braces
wrapping.and.braces.panel.force.case.branch.braces=Force 'case' branch braces
wrapping.and.braces.panel.force.finally.braces=Force 'finally' braces
wrapping.and.braces.panel.align.tuple.elements=Align tuple elements
wrapping.and.braces.panel.do.not.indent.tuples.closing.parenthesis=Do not indent tuples closing parenthesis
wrapping.and.braces.panel.do.not.align.block.expression.parameters=Do not align block expression parameters
wrapping.and.braces.panel.indent.braced.arguments=Indent braced arguments
wrapping.and.braces.panel.simple.one.line.lambdas.in.arg.list=Simple one-line lambdas in arg list
wrapping.and.braces.panel.keep.xml.formatting=Keep xml formatting
wrapping.and.braces.panel.place.self.type.on.new.line=Place self type on new line
wrapping.and.braces.panel.align.multiline.pattern.alternatives=Align multiline pattern alternatives
wrapping.and.braces.panel.align.in.columns.case.branches=Align in columns 'case' branches
wrapping.and.braces.panel.do.not.indent.case.clause.body=Do not indent case clause body
wrapping.and.braces.panel.match.statement='match' statement
wrapping.and.braces.panel.indent.first.parameter.clause.if.on.new.line=Indent first parameter clause if on new line
wrapping.and.braces.panel.indent.first.parameter.if.on.new.line=Indent first parameter if on new line
wrapping.and.braces.panel.align.parameter.types.in.multiline.declarations=Align parameter types in multiline declarations
wrapping.and.braces.panel.use.normal.indent.for.parameters=Use normal indent for parameters
wrapping.and.braces.panel.parameters.on.new.line=Parameters on new line
wrapping.and.braces.panel.wrap.before.with.keyword=Wrap before 'with' keyword
wrapping.and.braces.panel.align.if.else.statements=Align if-else statements
wrapping.and.braces.panel.indent=Indent
wrapping.and.braces.panel.new.line.options.no.new.line=No new line
wrapping.and.braces.panel.new.line.options.new.line.always=New line always
wrapping.and.braces.panel.new.line.options.new.line.for.multiple.arguments=New line for multiple arguments
wrapping.and.braces.panel.renamed.infix.expressions=Infix expressions
wrapping.and.braces.panel.renamed.extends.with.list=Extends/with list
wrapping.and.braces.panel.renamed.extends.keyword=Extends keyword
wrapping.and.braces.panel.renamed.force.yield.braces=Force yield braces

#Blank Lines
blank.lines.panel.around.method.in.inner.scopes=Around method in inner scopes
blank.lines.panel.around.field.in.inner.scopes=Around field in inner scopes

# Imports panel
imports.panel.title=Imports
imports.panel.class.count.to.use.import.with=Class count to use import with '_':
imports.panel.add.import.statement.in.closest.block=Add import statement in closest block
imports.panel.add.fully.qualified.imports=Add fully qualified imports
imports.panel.do.not.change.path.during.optimize.imports.for.local.imports=Do not change path during optimize imports for local imports
imports.panel.sort.imports.for.optimize.imports=Sort imports (for optimize imports):
imports.panel.lexicographically=lexicographically
imports.panel.scalastyle.consistent=scalastyle consistent
#TODO
imports.panel.merge.imports.with.the.same.prefix.into.one.statement=Merge imports with the same prefix into one statement
imports.panel.use.the.shortest.path.when.trying.to.import.reference.with.already.imported.name=Use the shortest path, when trying to import reference with already imported name 
imports.panel.classes.to.use.only.with.prefix=Classes to use only with prefix
imports.panel.import.layout=Import Layout
imports.panel.imports.always.marked.as.used=Imports always marked as used
imports.panel.add.pattern.to.use.appropriate.classes.only.with.prefix=Add pattern to use appropriate classes only with prefix
imports.panel.use.references.with.prefix=Use References With Prefix:
imports.panel.no.imports.with.prefix=No imports with prefix
imports.panel.add.package.name=Add package name
imports.panel.import.layout.manager=Import Layout Manager
imports.panel.add.import.to.always.mark.it.as.used=Add import to always mark it as used
imports.panel.always.mark.as.used=Always mark as used
imports.panel.honestly.mark.imports.as.unused=Honestly mark imports as unused

#Scaladoc panel
scaladoc.panel.title=ScalaDoc
scaladoc.panel.enable.scaladoc.formatting=Enable scaladoc formatting
scaladoc.panel.add.additional.space.for.leading.asterisk=Add additional space for leading asterisk
scaladoc.panel.groups.blank.lines=Blank lines
scaladoc.panel.groups.alignment=Alignment
scaladoc.panel.groups.other=Other
scaladoc.panel.align.parameter.descriptions=Align parameter descriptions
scaladoc.panel.align.throws.exception.descriptions=Align throws exception descriptions
scaladoc.panel.align.return.value.description=Align return value description
scaladoc.panel.align.other.tags.descriptions=Align other tags descriptions
scaladoc.panel.blank.lines.keep=Keep (blank lines between tags will not be removed)
scaladoc.panel.between.parameter.descriptions=Between parameter descriptions
scaladoc.panel.before.parameter.descriptions=Before parameter descriptions
scaladoc.panel.preserve.spaces.in.tags=Preserve spaces in tags

#Type Annotations panel
type.annotations.panel.title=Type Annotations
type.annotations.panel.classes=Classes
type.annotations.panel.annotations=Annotations
type.annotations.panel.type.patterns=Type Patterns
#Use for
type.annotations.panel.use.for=Use for
type.annotations.panel.public.member=Public member
type.annotations.panel.protected.member=Protected member
type.annotations.panel.private.member=Private member
type.annotations.panel.local.definition=Local definition
type.annotations.panel.function.literal.parameter=Function literal parameter
type.annotations.panel.underscore.parameter=Underscore parameter
#Enforce for
type.annotations.panel.enforce.for=Enforce for
type.annotations.panel.implicit.definition=Implicit definition
type.annotations.panel.unit.type=Unit type
type.annotations.panel.accidental.structural.type=Accidental structural type*
type.annotations.panel.accidental.structural.type.tooltip=<html>Enforces type annotations for values, which have structural type inferred, e.g.<br>\n<pre><code>\nval foo = Runnable {\n  override def run(): Unit = ()\n  def helper(): Unit = ()\n} // foo has inferred type Runnable { def helper(): Unit } \n</code></pre></html>
#Except when
type.annotations.panel.except.when=Except when
type.annotations.panel.member.of.anonymous.class=Member of anonymous class
type.annotations.panel.member.of.private.class=Member of private class
type.annotations.panel.member.of=Member of:
type.annotations.panel.annotated.with=Annotated with:
type.annotations.panel.constant.final.val=Constant (final val)
type.annotations.panel.type.is.stable=Type is stable*
type.annotations.panel.type.is.stable.tooltip=<html><body>When right-hand side is:<br> Literal: <code>123</code>, <code>\\"string\\"</code>, etc. (excluding <code>null</code>)<br> Unit expression: <code>()</code><br> Object creation: <code>new Foo(...)</code> (excluding one with refinement: <code>new Foo() {}</code>)<br> Factory method call: <code>Foo(...)</code> (calling <code>apply(...)</code> on companion object)<br> Empty collection: <code>Seq.empty[Int]</code>, <code>Map.empty[Int, String]</code>, etc.<br> Java enum constant: <code>Enum.VALUE</code><br> An exception: <code>throw Exception()</code> </body></html>
type.annotations.panel.type.matches=Type matches:
type.annotations.panel.in.test.sources=In test sources
type.annotations.panel.in.scala.dialect.sources=In Scala dialect sources*
type.annotations.panel.in.scala.dialect.sources.tooltip=*.sbt, *.sc, etc.

#Multi-line strings panel
multi.line.string.panel.title=Multi-line Strings
multi.line.string.panel.opening.quotes.on.new.line=Place &opening quotes on new line
multi.line.string.panel.place.closing.quotes.on.new.line.on.enter.press=Place &closing quotes on a new line on enter press
multi.line.string.panel.align.dangling.closing.quotes=&Align dangling closing quotes
multi.line.string.panel.insert.margin.char.on.enter=&Insert margin char for new lines on enter press
multi.line.string.panel.process.margin.on.copy.paste=&Strip/Insert margin on copy/paste
multi.line.string.panel.margin.char.value=Margin char:
multi.line.string.panel.margin.char.indent=Margin char indent:

#Rearranger panel
rearranger.panel.keep.scala.style.getters.and.setters.together=Keep scala-style getters and setters together
rearranger.panel.keep.java.style.getters.and.setters.together=Keep java-style getters and setters together
rearranger.panel.split.into.unarrangeable.blocks.by.expressions=Split into unarrangeable blocks by expressions
rearranger.panel.split.into.unarrangeable.blocks.by.implicits=Split into unarrangeable blocks by implicits

#Other panel
other.panel.title=Other
other.panel.enforce.functional.syntax.for.methods.with.unit.return.type=Enforce functional syntax for methods with Unit return type
other.panel.reformat.on.compile=Reformat on compile
other.panel.replace.with.unicode.symbol=Replace '=>' with unicode symbol
other.panel.replace.with.unicode.symbol1=Replace '->' with unicode symbol
other.panel.replace.in.for.generator.with.unicode.symbol=Replace '<-' in \\"for\\" generator with unicode symbol
other.panel.kind.projector.replace.lambda.with.unicode.symbol=Kind Projector: Replace 'Lambda' with unicode symbol
other.panel.alternate.indentation.for.constructor.args.and.parameter.declarations=Alternate indentation for constructor args and parameter declarations:
other.panel.spaces=spaces
other.panel.implicit.value.class.prefix.suffux=Implicit value class prefix / suffux
#Trailing comma
trailing.comma.panel.title=Trailing Comma
trailing.comma.panel.keep=Keep
trailing.comma.panel.remove.when.multiline=Remove when multiline
trailing.comma.panel.add.when.multiline=Add when multiline
trailing.comma.panel.scope.arguments.list=Arguments list
trailing.comma.panel.scope.parameters.list=Parameters list
trailing.comma.panel.scope.tuple=Tuple
trailing.comma.panel.scope.tuple.type=Tuple type
trailing.comma.panel.scope.pattern.arguments.list=Pattern arguments list
trailing.comma.panel.scope.type.parameters.list=Type parameters list
trailing.comma.panel.scope.import.selector=Import selector

scala.root.code.style.panel.formatter=Formatter

#Scalafmt
scalafmt.picked.new.config=Scalafmt picked up new style configuration (v{0})
scalafmt.default.label=Default
#
scalafmt.suggester.detected.in.project=Scalafmt configuration detected in this project
scalafmt.suggester.use.scalafmt.formatter=Use scalafmt formatter
scalafmt.suggester.continue.using.intellij.formatter=Continue using IntelliJ formatter
#
scalafmt.download=download
scalafmt.resolve.again=resolve again
scalafmt.progress.resolving.scalafmt.version=Resolving scalafmt version {0}
scalafmt.progress.downloading.scalafmt.version=Downloading scalafmt version {0}
scalafmt.progress.resolving.scalafmt.version.cancel=Stop Resolving
scalafmt.progress.downloading.scalafmt.version.cancel=Stop Downloading
scalafmt.progress.version.was.downloaded=Scalafmt version {0} was downloaded
#Code style panel
scalafmt.settings.panel.show.warnings.when.formatting.invalid.code=Show warnings when trying to format invalid code
scalafmt.settings.panel.use.intellij.formatter.for.code.range.formatting=Use IntelliJ formatter for code range formatting
scalafmt.settings.panel.use.intellij.formatter.for.code.range.formatting.warning.tooltip=Using Scalafmt to format code ranges can lead to code inconsistencies.<br>Scalafmt is designed to only format entire files with scala code
scalafmt.settings.panel.reformat.on.file.save=Reformat on file save
scalafmt.settings.panel.configuration.label=Configuration
scalafmt.settings.panel.scalafmt.version.label=Scalafmt version
scalafmt.settings.panel.select.custom.scalafmt.configuration.file=Select custom scalafmt configuration file
scalafmt.settings.panel.no.config.found.under.path.using.default=No configuration found under specified path, using default IntelliJ configuration
#
scalafmt.config.load.errors.failed.to.load.config=Failed to load scalafmt config
scalafmt.config.load.errors.file.not.found=file not found
scalafmt.config.load.errors.parse.error=parse error: {0}
scalafmt.config.load.errors.unknown.error=unknown error: {0}
scalafmt.config.load.actions.open.config.file=open config file
#
scalafmt.resolve.errors.cant.resolve.scalafmt.version=Can not resolve scalafmt version {0}
scalafmt.resolve.errors.version.is.not.downloaded.yet=Scalafmt version `{0}` is not downloaded yet.<br>Would you like to to download it?
scalafmt.resolve.errors.download.is.in.progress=Download is in progress
scalafmt.resolve.errors.downloading.error.occurred=An error occurred during downloading
scalafmt.resolve.errors.classpath.is.corrupted=Classpath is corrupted
scalafmt.resolve.errors.unknown.error=Unknown error
#
#0:file link;1:error message
scalafmt.format.errors.scala.file.parse.error=Scalafmt parse error ({0}):<br>{1}
#0:file link;1:error message
scalafmt.format.errors.failed.to.find.correct.surrounding.code=Scalafmt error ({0}):<br>failed to find correct surrounding code to pass for scalafmt, no formatting will be performed
#
scalafmt.settings.panel.errors.cant.resolve.version=Can not resolve scalafmt version {0}
scalafmt.settings.panel.errors.failed.to.parse.config=Failed to parse configuration:<br> {0}
scalafmt.settings.panel.errors.cant.find.config.file=Can not find scalafmt config file with path:<br> {0}

########################################################################################################################
# Worksheet
########################################################################################################################
worksheet.settings.panel.title=Worksheet Settings
worksheet.settings.panel.change.make.button=Make project before run
worksheet.settings.panel.interactive.mode=Interactive Mode
worksheet.settings.panel.run.type=Run type:
worksheet.settings.panel.use.class.path.of.module=Use class path of module:
worksheet.settings.panel.compiler.profile=Compiler profile:
worksheet.settings.panel.using.class.path.of.the.module=Using class path of the module...
worksheet.settings.panel.settings.for.module=Settings for {0}
worksheet.settings.panel.default.settings=Default settings
worksheet.compilation=Worksheet {0} compilation
worksheet.configuration.errors.base=Worksheet configuration error
worksheet.configuration.errors.repl.is.available.only.in.compile.server.process=Worksheet in REPL mode can only be executed in compile server process
worksheet.configuration.errors.enable.compile.server=Enable compile server
worksheet.configuration.errors.configure.compile.server=Configure compile server
worksheet.printers.output.exceeds.cutoff.limit=Output exceeds cutoff limit.
worksheet.internal.error=Internal error