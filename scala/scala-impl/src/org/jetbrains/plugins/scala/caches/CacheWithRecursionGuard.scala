package org.jetbrains.plugins.scala.caches

import com.intellij.psi.PsiElement
import com.intellij.psi.util.PsiTreeUtil
import org.jetbrains.plugins.scala.caches.stats.Tracer
import org.jetbrains.plugins.scala.lang.psi.api.statements.ScFunction
import org.jetbrains.plugins.scala.lang.psi.api.toplevel.typedef.ScTemplateDefinition
import org.jetbrains.plugins.scala.util.UIFreezingGuard

object CacheWithRecursionGuard {
  // TODO cacheWithRecursionGuard0[R] == cacheWithRecursionGuardN[Unit, R]
  // Code generated by @CachedWithRecursionGuard macro annotation, method without parameters
  def cacheWithRecursionGuard0[R](id: String, name: String, element: PsiElement, defaultValue: => R, dependencyItem: => AnyRef, f: => R): R = {
    val data: Unit = ()
    val dataForGuard = element
    val key = CachesUtil.getOrCreateKey[CachesUtil.CachedRef[R]](id)
    val tracer = Tracer(id, name)
    tracer.invocation()
    val holder = CachesUtil.getOrCreateCachedRef[PsiElement, R](element, key, id, name, () => dependencyItem)
    val fromCachedHolder = holder.get()
    if (fromCachedHolder != null) {
      return fromCachedHolder
    }
    val guard = RecursionManager.RecursionGuard[PsiElement, R](key.toString)
    if (guard.checkReentrancy(dataForGuard)) {
      return CachesUtil.handleRecursiveCall(element, data, key, defaultValue)
    }
    tracer.calculationStart()
    try {
      val fromLocalCache = guard.getFromLocalCache(dataForGuard)
      if (fromLocalCache != null) {
        fromLocalCache
      } else {
        val realKey = guard.createKey(dataForGuard)
        val (sizeBefore, sizeAfter, minDepth, localCacheBefore) = guard.beforeComputation(realKey)
        val (result, shouldCache) = try {
          val stackStamp = RecursionManager.markStack()
          val result = try {
            val guardedResult = if (UIFreezingGuard.isAlreadyGuarded) {
              f
            } else {
              UIFreezingGuard.withResponsibleUI {
                f
              }
            }
            guardedResult
          } catch {
            case exc: CachesUtil.ProbablyRecursionException[_] if exc.key == key =>
              if (exc.elem == element && exc.data == data) {
                try {
                  val guardedResult = if (UIFreezingGuard.isAlreadyGuarded) {
                    f
                  } else {
                    UIFreezingGuard.withResponsibleUI {
                      f
                    }
                  }
                  guardedResult
                } finally {
                  exc.set.foreach(fun => fun.isProbablyRecursive = false)
                }
              } else {
                val fun = PsiTreeUtil.getContextOfType(element, true, classOf[ScFunction])
                if (fun == null || fun.isProbablyRecursive) {
                  throw exc
                } else {
                  fun.isProbablyRecursive = true
                  throw exc.copy(set = exc.set + fun)
                }
              }
          }
          val shouldCache = stackStamp.mayCacheNow()
          (result, shouldCache)
        } finally {
          guard.afterComputation(realKey, sizeBefore, sizeAfter, minDepth, localCacheBefore)
        }
        if (shouldCache) {
          val race = {
            holder.compareAndSet(null.asInstanceOf[R], result)
            holder.get()
          }
          if (race != null) race else result
        } else {
          guard.cacheInLocalCache(dataForGuard, result)
          result
        }
      }
    } finally {
      tracer.calculationEnd()
    }
  }

  // Code generated by @CachedWithRecursionGuard macro annotation, method with parameters
  def cacheWithRecursionGuardN[T <: Product, R](
    id: String,
    name: String,
    element: PsiElement,
    defaultValue: => R,
    dependencyItem: => AnyRef,
    data: T,
    f: => R
  ): R = {
    val key = CachesUtil.getOrCreateKey[CachesUtil.CachedMap[T, R]](id)
    val tracer = Tracer(id, name)
    tracer.invocation()
    val holder = CachesUtil.getOrCreateCachedMap[PsiElement, T, R](element, key, id, name, () => dependencyItem)
    val fromCachedHolder = holder.get(data)
    if (fromCachedHolder != null) {
      return fromCachedHolder
    }

    val dataForGuard = (element, data)
    val guard = RecursionManager.RecursionGuard[(PsiElement, T), R](key.toString)
    if (guard.checkReentrancy(dataForGuard)) {
      return CachesUtil.handleRecursiveCall(element, data, key, defaultValue)
    }
    tracer.calculationStart()
    try {
      val fromLocalCache = guard.getFromLocalCache(dataForGuard)
      if (fromLocalCache != null) {
        fromLocalCache
      } else {
        val realKey = guard.createKey(dataForGuard)
        val (sizeBefore, sizeAfter, minDepth, localCacheBefore) = guard.beforeComputation(realKey)
        val (result, shouldCache) = try {
          val stackStamp = RecursionManager.markStack()
          val result = try {
            val guardedResult = if (UIFreezingGuard.isAlreadyGuarded) {
              f
            } else {
              UIFreezingGuard.withResponsibleUI {
                f
              }
            }
            guardedResult
          } catch {
            case exc: CachesUtil.ProbablyRecursionException[_] if exc.key == key =>
              handleRecursionException(exc, element, data, f)
          }

          val shouldCache = stackStamp.mayCacheNow()
          (result, shouldCache)
        } finally {
          guard.afterComputation(realKey, sizeBefore, sizeAfter, minDepth, localCacheBefore)
        }

        if (shouldCache) {
          val race = holder.putIfAbsent(data, result)
          if (race != null)
            race
          else
            result
        } else {
          guard.cacheInLocalCache(dataForGuard, result)
          result
        }
      }
    } finally {
      tracer.calculationEnd()
    }
  }

  private def handleRecursionException[T <: Product, R](
    exc: CachesUtil.ProbablyRecursionException[_],
    element: PsiElement,
    data: T,
    f: => R
  ): R = {
    if (exc.elem == element && exc.data == data) {
      try {
        val guardedResult = if (UIFreezingGuard.isAlreadyGuarded) {
          f
        } else {
          UIFreezingGuard.withResponsibleUI {
            f
          }
        }
        guardedResult
      } finally {
        exc.set.foreach(_.isProbablyRecursive = false)
      }
    } else {
      //TODO: logic is duplicated in org.jetbrains.plugins.scala.caches.CachesUtil.handleRecursiveCall
      //handle recursive MixinNodes.build
      element match {
        case clazz: ScTemplateDefinition =>
          if (clazz.isProbablyRecursive)
            throw exc
          else {
            clazz.isProbablyRecursive = true
            throw exc.copy(set = exc.set + clazz)
          }
        case _ =>
      }

      val fun = PsiTreeUtil.getContextOfType(element, true, classOf[ScFunction])
      if (fun == null || fun.isProbablyRecursive) {
        throw exc
      } else {
        fun.isProbablyRecursive = true
        throw exc.copy(set = exc.set + fun)
      }
    }
  }

/*
@CachedWithRecursionGuard(element, "default", ModTracker.anyScalaPsiChange)
def foo(): String = "Foo"

def foo(): String = {
  val org$example$Example$foo$element = element;
  val org$example$Example$foo$data = ();
  val org$example$Example$foo$dataForGuard = org$example$Example$foo$element;
  val org$example$Example$foo$key = _root_.org.jetbrains.plugins.scala.caches.CachesUtil.getOrCreateKey[_root_.org.jetbrains.plugins.scala.caches.CachesUtil.CachedRef[String]]("org$example$Example$foo$cacheKey");
  def org$example$Example$foo$defaultValue: String = "default";
  val org$example$Example$foo$$tracer = _root_.org.jetbrains.plugins.scala.caches.stats.Tracer("org$example$Example$foo$cacheKey", "Example.foo");
  org$example$Example$foo$$tracer.invocation();
  val org$example$Example$foo$holder = _root_.org.jetbrains.plugins.scala.caches.CachesUtil.getOrCreateCachedRef[_root_.com.intellij.psi.PsiElement, String](org$example$Example$foo$element, org$example$Example$foo$key, "org$example$Example$foo$cacheKey", "Example.foo", (() => ModTracker.anyScalaPsiChange));
  val fromCachedHolder = org$example$Example$foo$holder.get();
  if (fromCachedHolder.$bang$eq(null))
    return fromCachedHolder
  else
    ();
  val org$example$Example$foo$guard = org.jetbrains.plugins.scala.caches.RecursionManager.RecursionGuard[_root_.com.intellij.psi.PsiElement, String](org$example$Example$foo$key.toString);
  if (org$example$Example$foo$guard.checkReentrancy(org$example$Example$foo$dataForGuard))
    return _root_.org.jetbrains.plugins.scala.caches.CachesUtil.handleRecursiveCall(org$example$Example$foo$element, org$example$Example$foo$data, org$example$Example$foo$key, org$example$Example$foo$defaultValue)
  else
    ();
  org$example$Example$foo$$tracer.calculationStart();
  try {
    val fromLocalCache = org$example$Example$foo$guard.getFromLocalCache(org$example$Example$foo$dataForGuard);
    if (fromLocalCache.$bang$eq(null))
      fromLocalCache
    else
      {
        val realKey = org$example$Example$foo$guard.createKey(org$example$Example$foo$dataForGuard);
        <synthetic> <artifact> private[this] val x$1 = org$example$Example$foo$guard.beforeComputation(realKey): @scala.unchecked match {
          case scala.Tuple4((sizeBefore @ _), (sizeAfter @ _), (minDepth @ _), (localCacheBefore @ _)) => scala.Tuple4(sizeBefore, sizeAfter, minDepth, localCacheBefore)
        };
        val sizeBefore = x$1._1;
        val sizeAfter = x$1._2;
        val minDepth = x$1._3;
        val localCacheBefore = x$1._4;
        <synthetic> <artifact> private[this] val x$2 = try {
          val stackStamp = org.jetbrains.plugins.scala.caches.RecursionManager.markStack();
          val result = try {
            val __guardedResult__: String = if (_root_.org.jetbrains.plugins.scala.util.UIFreezingGuard.isAlreadyGuarded)
              "Foo"
            else
              _root_.org.jetbrains.plugins.scala.util.UIFreezingGuard.withResponsibleUI("Foo");
            __guardedResult__
          } catch {
            case (exc @ (_: org.jetbrains.plugins.scala.caches.CachesUtil.ProbablyRecursionException[(_ @ <empty>)])) if exc.key.$eq$eq(org$example$Example$foo$key) => if (exc.elem.$eq$eq(org$example$Example$foo$element).$amp$amp(exc.data.$eq$eq(org$example$Example$foo$data)))
              try {
                val __guardedResult__: String = if (_root_.org.jetbrains.plugins.scala.util.UIFreezingGuard.isAlreadyGuarded)
                  "Foo"
                else
                  _root_.org.jetbrains.plugins.scala.util.UIFreezingGuard.withResponsibleUI("Foo");
                __guardedResult__
              } finally exc.set.foreach(((fun) => fun.isProbablyRecursive = false))
            else
              {
                val fun = com.intellij.psi.util.PsiTreeUtil.getContextOfType(org$example$Example$foo$element, true, classOf[org.jetbrains.plugins.scala.lang.psi.api.statements.ScFunction]);
                if (fun.$eq$eq(null).$bar$bar(fun.isProbablyRecursive))
                  throw exc
                else
                  {
                    fun.isProbablyRecursive = true;
                    throw exc.copy(set = exc.set.$plus(fun))
                  }
              }
          };
          val shouldCache = stackStamp.mayCacheNow();
          scala.Tuple2(result, shouldCache)
        } finally org$example$Example$foo$guard.afterComputation(realKey, sizeBefore, sizeAfter, minDepth, localCacheBefore): @scala.unchecked match {
          case scala.Tuple2((result @ _), (shouldCache @ _)) => scala.Tuple2(result, shouldCache)
        };
        val result = x$2._1;
        val shouldCache = x$2._2;
        if (shouldCache)
          {
            val race = {
              org$example$Example$foo$holder.compareAndSet(null, result);
              org$example$Example$foo$holder.get()
            };
            if (race.$bang$eq(null))
              race
            else
              result
          }
        else
          {
            org$example$Example$foo$guard.cacheInLocalCache(org$example$Example$foo$dataForGuard, result);
            result
          }
      }
  } finally org$example$Example$foo$$tracer.calculationEnd()
}

@CachedWithRecursionGuard(element, "default", ModTracker.anyScalaPsiChange)
def foo(x: Int): String = "Foo"

def foo(x: Int): String = {
  val org$example$Example$foo$element = element;
  val org$example$Example$foo$data = x;
  val org$example$Example$foo$dataForGuard = scala.Tuple2(org$example$Example$foo$element, org$example$Example$foo$data);
  val org$example$Example$foo$key = _root_.org.jetbrains.plugins.scala.caches.CachesUtil.getOrCreateKey[_root_.org.jetbrains.plugins.scala.caches.CachesUtil.CachedMap[Int, String]]("org$example$Example$foo$cacheKey");
  def org$example$Example$foo$defaultValue: String = "default";
  val org$example$Example$foo$$tracer = _root_.org.jetbrains.plugins.scala.caches.stats.Tracer("org$example$Example$foo$cacheKey", "Example.foo");
  org$example$Example$foo$$tracer.invocation();
  val org$example$Example$foo$holder = _root_.org.jetbrains.plugins.scala.caches.CachesUtil.getOrCreateCachedMap[_root_.com.intellij.psi.PsiElement, Int, String](org$example$Example$foo$element, org$example$Example$foo$key, "org$example$Example$foo$cacheKey", "Example.foo", (() => ModTracker.anyScalaPsiChange));
  val fromCachedHolder = org$example$Example$foo$holder.get(org$example$Example$foo$data);
  if (fromCachedHolder.$bang$eq(null))
    return fromCachedHolder
  else
    ();
  val org$example$Example$foo$guard = org.jetbrains.plugins.scala.caches.RecursionManager.RecursionGuard[scala.Tuple2[_root_.com.intellij.psi.PsiElement, Int], String](org$example$Example$foo$key.toString);
  if (org$example$Example$foo$guard.checkReentrancy(org$example$Example$foo$dataForGuard))
    return _root_.org.jetbrains.plugins.scala.caches.CachesUtil.handleRecursiveCall(org$example$Example$foo$element, org$example$Example$foo$data, org$example$Example$foo$key, org$example$Example$foo$defaultValue)
  else
    ();
  org$example$Example$foo$$tracer.calculationStart();
  try {
    val fromLocalCache = org$example$Example$foo$guard.getFromLocalCache(org$example$Example$foo$dataForGuard);
    if (fromLocalCache.$bang$eq(null))
      fromLocalCache
    else
      {
        val realKey = org$example$Example$foo$guard.createKey(org$example$Example$foo$dataForGuard);
        <synthetic> <artifact> private[this] val x$1 = org$example$Example$foo$guard.beforeComputation(realKey): @scala.unchecked match {
          case scala.Tuple4((sizeBefore @ _), (sizeAfter @ _), (minDepth @ _), (localCacheBefore @ _)) => scala.Tuple4(sizeBefore, sizeAfter, minDepth, localCacheBefore)
        };
        val sizeBefore = x$1._1;
        val sizeAfter = x$1._2;
        val minDepth = x$1._3;
        val localCacheBefore = x$1._4;
        <synthetic> <artifact> private[this] val x$2 = try {
          val stackStamp = org.jetbrains.plugins.scala.caches.RecursionManager.markStack();
          val result = try {
            val __guardedResult__: String = if (_root_.org.jetbrains.plugins.scala.util.UIFreezingGuard.isAlreadyGuarded)
              "Foo"
            else
              _root_.org.jetbrains.plugins.scala.util.UIFreezingGuard.withResponsibleUI("Foo");
            __guardedResult__
          } catch {
            case (exc @ (_: org.jetbrains.plugins.scala.caches.CachesUtil.ProbablyRecursionException[(_ @ <empty>)])) if exc.key.$eq$eq(org$example$Example$foo$key) => if (exc.elem.$eq$eq(org$example$Example$foo$element).$amp$amp(exc.data.$eq$eq(org$example$Example$foo$data)))
              try {
                val __guardedResult__: String = if (_root_.org.jetbrains.plugins.scala.util.UIFreezingGuard.isAlreadyGuarded)
                  "Foo"
                else
                  _root_.org.jetbrains.plugins.scala.util.UIFreezingGuard.withResponsibleUI("Foo");
                __guardedResult__
              } finally exc.set.foreach(((fun) => fun.isProbablyRecursive = false))
            else
              {
                val fun = com.intellij.psi.util.PsiTreeUtil.getContextOfType(org$example$Example$foo$element, true, classOf[org.jetbrains.plugins.scala.lang.psi.api.statements.ScFunction]);
                if (fun.$eq$eq(null).$bar$bar(fun.isProbablyRecursive))
                  throw exc
                else
                  {
                    fun.isProbablyRecursive = true;
                    throw exc.copy(set = exc.set.$plus(fun))
                  }
              }
          };
          val shouldCache = stackStamp.mayCacheNow();
          scala.Tuple2(result, shouldCache)
        } finally org$example$Example$foo$guard.afterComputation(realKey, sizeBefore, sizeAfter, minDepth, localCacheBefore): @scala.unchecked match {
          case scala.Tuple2((result @ _), (shouldCache @ _)) => scala.Tuple2(result, shouldCache)
        };
        val result = x$2._1;
        val shouldCache = x$2._2;
        if (shouldCache)
          {
            val race = org$example$Example$foo$holder.putIfAbsent(org$example$Example$foo$data, result);
            if (race.$bang$eq(null))
              race
            else
              result
          }
        else
          {
            org$example$Example$foo$guard.cacheInLocalCache(org$example$Example$foo$dataForGuard, result);
            result
          }
      }
  } finally org$example$Example$foo$$tracer.calculationEnd()
}
*/
}
