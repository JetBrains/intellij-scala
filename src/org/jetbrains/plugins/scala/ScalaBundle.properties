#
# Copyright 2000-2008 JetBrains s.r.o.
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
# http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
#

#
# Copyright 2000-2007 JetBrains s.r.o.
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
# http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
#

#
# Copyright 2000-2006 JetBrains s.r.o.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
# http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
#


########################################################################################################################
# Load SDK
########################################################################################################################
sdk.title=Scala SDK

########################################################################################################################
# Parser error messages
########################################################################################################################
statement.expected=Block statement expected
package.qualID.expected=Package qualified identifier expected
lbrace.expected='{' expected
rbrace.expected='}' expected
rsqbracket.expected=']' expected
rparenthesis.expected=')' expected
semi.expected=';' or newline expected
choose.expected='<-' expected in generator statement
assign.expected='=' expected
star.expected='*' expected
colon.expected=':' expected
parameter.type.expected=Parameter type expected
case.clauses.expected=Case clauses expected
case.clauses.or.qualified.reference.expected=Case clauses or qualified reference expected
while.expected=While keyword expected in the 'do' statement
enumerators.expected=Enumerators expected in the 'for' statement
wrong.qual.identifier=Wrong qualified identifier
identifier.expected=Identifier expected
identifier.or.wild.sign.expected=Identifier or '_' expected
dot.expected='.' expected
dot.or.cq.expected='.' or class qualifier expected
out.of.compilation.unit=Out of compilation unit
wrong.var.declaration=Wrong variable declaration
wrong.val.declaration=Wrong value declaration
wrong.type=Wrong type
wrong.parameter=Wrong parameter
wrong.case.modifier=Wrong case modifier. Use it with class or object
wrong.import.statment.end=Wrong import statment tale
wrong.expression=Wrong expression
wrong.postfix.expression=Wrong postfix expression
wrong.existential.declaration=Wrong existential declaration. It must be type or value declaration
wrong.annotation.expression=Wrong annotation expression
wrong.pattern=Wrong pattern
wrong.binding=Wrong parameter
annotation.expected=Annotation expected
import.selector.expected=Import selector expected
simple.type.expected.requires=Simple type expected in requires block
unreachable.error=Unexpected error found
val.var.expected=Val or var keyword expected
def.dcl.expected=Definition or declaration expected
block.expected=Block expected
type.tale.expected=Type keyword expected im simple type tale
existential.block.expected=Existential clause expected
fun.sign.expected='=>' expected
pattern.expected=Pattern expected
compound.type.expected=Compound type expected
condition.expected=Boolean condition expected
simple.pattern.expected=Illegal start of simple pattern
constr.block.expected=Constructor block expected
wrong.constr.expression=Wrong constructor expression
param.clause.expected=Parameter clause expected
this.expected='this' keyword expected
arg.expr.expected=Argument expression expected
implicit.params.excepted=Implicit parameter clause must have at least one parameter
wrong.type.associativity=Wrong associativity. All operators should have the same associativity
wrong.top.statment.declaration=Wrong top statement declaration
wrong.simple.type=Wrong simple type
xml.tag.end.expected=Xml tag end expected
xml.end.tag.expected=Xml end tag ('</' name '>') expected
xml.name.expected=Xml tag name expected
xml.scala.injection.end.expected=Scala injection end ('}') in xml expected
xml.scala.expression.exected=Scala expression expected in injection in xml
xml.PI.end.expected=Xml proccessing instructions end expected
xml.comment.end.expected=Xml comment end ('-->') expected
xml.wrong.character=Wrong character in xml comment
xml.cdata.end.expected=Xml CData end expected
xml.attribute.end.expected=Xml attribute value end delimiter expected
xml.eq.expected='=' expected
xml.attribute.value.expected=Attribute value expected
xml.scala.patterns.exected=Scala patterns expected in injection in xml
return.outside.method.definition=Return statement outside method definition
unbound.placeholder.parameter=Unbound placeholder parameter
local.variables.must.be.initialized=Local variables must be initialiazed
expr.type.does.not.conform={0} type in expression doesn''t conform to value declared type
expr.type.does.not.conform.expected.type=Expression of type {0} doesn''t conform to expected type {1}
patt.type.does.not.conform.expr.type=Expected type for pattern {0} doesn''t conform to expression type {1}

########################################################################################################################
# Building caches
########################################################################################################################
title.cache.updating=Updating caches
title.cache.creating=Creating caches
title.cache.files.scanning=Scanning files...
title.cache.files.parsing=Parsing new files...
title.please.wait=Please wait
title.cache.saving=Saving caches
title.cache.datafile.loading=Loading caches
title.cache.files.removing=Removing old caches
title.cache.loading=Loading caches

########################################################################################################################
# Error reports
########################################################################################################################
error.report.to.jetbrains.action=Report To Jetbrains
error.report.submit.label=<html>This error report will be created as new <b>JIRA</b> issue \
  <br><b>''{0}''</b><br>at \
  <b><a href="{1}{2}">{1}{2}</a></b> <br>as component <b>''{3}''</b>.\
  <br><br>Please provide a short description of the error and how can it be reproduced:</html>
error.report.submit.register.in.jira=<html><a href="{0}">Signup for an account</a></html>
error.report.submit.new.issue.url=<html>Your issue was successfully added, see<br>     <a href="{0}">{0}</a></html>
error.report.submit.new.issue.title=Issue Added
error.report.wrong.login=Invalid username or password.
error.report.canceled=Canceled sending report
error.report.error.creating.issue=Error creating new JIRA issue
error.report.jira.issue=JetScala issue #{0}
error.report.dialog.title=Submit Error
error.report.dialog.wrong.password.title=Sending Failed
error.report.button.sendreport.caption=&Send Report
error.report.button.cancel.caption=&Cancel
error.report.form.not.jira=&I do not have a JIRA account, create issue on behalf of 'JetScala error reporter'
error.report.form.jira=I'm a &JIRA user
error.report.form.jira.login=&Login
error.report.form.jira.password=&Password
error.report.form.jira.password.save=Save password
repetitive.method.name.signature=Repetitive method name/signature
repetitive.method.name.signature.and.return.type=repetitive method name, signature and return type
illegal.combination.of.modifiers=illegal combination of modifiers
modifier.is.not.allowed.here.0=modifier ''{0}'' is not allowed here
illegal.combination.of.modifiers.abstract.and.final=illegal combination of modifiers 'abstract' and 'final'
modifier.volatile.not.allowed.here=modifier 'volatile' not allowed here
modifier.transient.not.allowed.here=modifier 'transient' not allowed here
intarface.cannot.have.modifier.final=interface cannot have modifier 'final'
script.cannot.have.modifier.abstract=script cannot have modifier 'abstract'
script.cannot.have.modifier.native=script cannot have modifier 'native'
interface.must.have.no.static.method=interface must have no static method
not.abstract.class.cannot.have.abstract.method=not abstract class cannot have abstract method
illegal.combination.of.modifiers.volatile.and.final=illegal combination of modifiers 'volatile' and 'final'
variable.cannot.be.native=variable cannot have modifier 'native'
variable.cannot.be.abstract=variable cannot have modifier 'abstract'
not.abstract.class.cannot.have.method.without.body=not abstract class cannot have method without body
not.abstract.method.should.have.body=not abstract method should have body
cannot.create.class.error.text=Cannot Create Class ''{0}'': {1}
cannot.create.class.error.title=Cannot Create Class
no.class.in.file.template=No Class Found in File Template
interface.must.have.no.private.method=interface must have no private method
error.external=External error
Inner.methods.are.not.supported=Inner methods are not supported
final.class.cannot.be.extended=Final class cannot be extended
cannot.resolve=Cannot resolve symbol {0}
cannot.resolve.apply.method=Cannot resolve method {0}.apply
cannot.resolve.in.StringContext=Value ''{0}'' is not a member of StringContext
cannot.resolve.such.signature=Cannot resolve reference {0} with such signature
element.is.not.accessible=Element {0} has private access from this place
class.must.declared.abstract=Class ''{0}'' must be declared abstract or implement inherited abstract members
object.must.implement=Object ''{0}'' must implement not implemented methods
only.for.scala=This works only with scala files
cannot.refactor.no.function=Can't find function for introduce parameter
cannot.refactor.not.expression=Selected block should be presented as expression
cannot.refactor.constr.expression=Selected block shouldn't be presented as constructor expression
cannot.refactor.constructor.parameter.top.level=Refactoring is not supported for constructor parameters in top level classes
cannot.refactor.under.generic.call=Refactoring is not supported in generic calls
cannot.refactor.arg.in.self.invocation.of.constructor=Refactoring is not supported for arguments of self-invocation in the constructor body
cannot.refactor.named.arg=Refactoring is not supported for named arguments
cannot.refactor.literal.pattern=Refactoring is not supported for literal patterns
cannot.refactor.class.parameter.top.level=Refactoring is not supported for parameters of top level classes
refactoring.is.not.supported.in.guard=Refactoring is not supported in guards, it most likely break code structure
wrong.refactoring.context=Refactoring is not supported in current context
operation.not.supported.in.current.block=Operation is not supported in current block
file.is.not.writable=File hasn't access to be writable
introduced.variable.will.conflict.with.local=Introduced variable conflicts with (or may be hidden by) local variable: {0}
introduced.variable.will.conflict.with.parameter=Introduced variable conflicts with (or may be hidden by) parameter: {0}
introduced.variable.will.conflict.with.field=Introduced variable will conflicts with (or may be hidden by) field or method \
  without parameters: {0}
introduced.variable.will.conflict.with.class.parameter=Introduced variable conflicts with (or may be hidden by) class parameter: {0}
class.import.title=Add import for class:
select.method.override=Select Members to Override
select.method.implement=Select Members to Implement
wrong.declaration.in.block=Block cannot contain declarations
import.expr.should.be.qualified=Import expression must be qualified
cannot.extract.empty.message=Wrong selection for extract method. Number of complete expressions or statements expected.
cannot.extract.self.invocation=Cannot extract self invocation.
cannot.extract.used.function.definition=Refactoring is not supported: function definition inside selection is used out of the selected fragment
cannot.extract.used.type.definition=Refactoring is not supported: type definition inside selection is used out of the selected fragment
method.is.not.member=Method {0} is not a member of type {1}
expected.type.boolean=Expected type Boolean as method {0} return type
xml.no.opening.tag=No Opening Tag
xml.no.closing.tag=No Closing Tag
cannot.inline.used.outside.class=Member is used outside of the containing class. Inline is not supported.
cannot.inline.stable.reference=Value is used in a stable reference and cannot be inlined
cannot.inline.never.used=Variable is never used.
cannot.inline.not.simple.pattern=Inline is supported only for simple pattern definitions
cannot.inline.recursive.function=Inline is not supported for recursive functions
cannot.inline.anonymous.function=Inline of anonymous functions with arguments is not supported
0.is.not.a.legal.scala.identifier=''{0}'' is not a legal scala identifier
########################################################################################################################
# FunctionAnnotator
########################################################################################################################

function.must.define.type.explicitly=Method {0} has return statement; needs result type
function.recursive.need.result.type=Recursive method {0} needs result type
return.type.does.not.conform=Type mismatch: found {0}, required {1}
return.expression.does.not.conform=Type mismatch: found {0}, required {1}
return.expression.is.redundant=Returning {0} from a method with Unit result type
cannot.have.implicit.parameters.and.implicit.bounds=Cannot have both implicit parameters and context bounds `: ...' or view bounds `<% ...' on type parameters

########################################################################################################################
# Annotator reports
########################################################################################################################

block.must.end.result.expression=Block must end in result expression
member.needs.override.modifier={0} ''{1}'' needs override modifier
illegal.cyclic.reference=Illegal cyclic reference ''{0}''
member.overrides.nothing={0} ''{1}'' overrides nothing
implements.method.from.super=Implements method in ''{0}''
overrides.method.from.super=Overrides method in ''{0}''
implements.val.from.super=Implements values in ''{0}''
overrides.val.from.super=Overrides values in ''{0}''
overrides.type.from.super=Overrides types in ''{0}''
goto.override.method.declaration=Choose super method
goto.override.val.declaration=Choose super for values
goto.override.type.declaration=Choose super for types
anonymous.class.must.declared.abstract=Anonymous class must implement inherited abstract members
trait.has.implementations=Trait has implementations
class.has.subclasses=Class has subclasses
object.has.subclasses=Object has subclasses
goto.implementation.chooser.title=<html>Choose implementation of <b>{0}</b> ({1} classes found)</html>
navigation.title.subclass=<html>Choose subclass of <b>{0}</b> ({1} classes found)</html>
has.implementations=Has implementations
is.overriden.by=Is overriden by...
navigation.title.implementation.member=<html>Choose implementing member of <b>{0}</b> ({1} member found)</html>
navigation.title.overrider.member=<html>Choose overriding member of <b>{0}</b> ({1} member found)</html>
goto.super.member.chooser.title=Choose supermember
goto.super.class.chooser.title=Choose superclass
goto.super.class.or.member.chooser.title=Choose superclass / supermember
cyclic.reference.type=Illegal cyclic reference involving type {0}
lazy.modifier.is.not.allowed.here='lazy' modifier allowed only with value definitions
lazy.modifier.is.not.allowed.with.param='lazy' modifier not allowed here, use call-by-name parameter instead
lazy.values.may.not.be.abstract=lazy values may not be abstract
final.modifier.not.with.declarations='final' modifier can't be used with incomplete members
final.modifier.not.with.trait='final' modifier not allowed with trait
final.modifier.is.redundant.with.object='final' modifier is redundant for objects
final.modifier.is.redundant.with.final.parents='final' modifier is redundant for objects or final class members
final.modifier.is.not.allowed.here='final' modifier is not allowed here
abstract.modifier.redundant.fot.traits='abstract' modifier is redundant for traits
abstract.modifier.is.not.allowed='abstract' modifier allowed only for classes or for definitions with 'override' modifier
abstract.override.modifier.is.not.allowed='abstract override' modifier only allowed for members of traits
override.modifier.is.not.allowed.for.classes='override' modifier allowed only for type definitions members
override.modifier.is.not.allowed='override' modifier is not allowed here
sealed.modifier.is.not.allowed.here='sealed' modifier is not allowed here
illegal.modifiers.combination=Illegal modifiers combination: {0} and {1}
id.is.already.defined={0} is already defined in the scope
implicit.usage.tooltip=<html>\
  <body>\
  Implicit conversion {0}(<b>{1}</b>): <b>{2}</b> detected
  </body>\
  </html>
implicit.usage.message=Implicit conversion ''{0}({1}): {2}'' detected.
val.on.case.class.param.redundant='val' modifier is redundant for parameter of case class primary constructor
suspicicious.inference=Inferred type of {0} is suspicious. If you really want this, explicitly annotate the type.
suspicicious.newline=Newline before argument list is not inferred as a semicolon. Consider using '.' before the method name.
constructor.invocation.expected='this' expected
called.constructor.definition.must.precede=Called constructor's definition must precede calling constructor's definition
scala.mutable.collection=Mutable Collection
scala.immutable.collection=Immutable Collection
java.collection=Java Collection
pattern.on.refinement.unchecked=a pattern match on a refinement type is unchecked
type.cannot.be.used.in.type.pattern=type {0} cannot be used in a type pattern or isInstanceOf test
scrutinee.incompatible.pattern.type=scrutinee is incompatible with pattern type; found: {0}; required: {1}
fruitless.type.test=fruitless type test: a value of type {0} cannot also be a {1}
erasure.warning= (but still might match its erasure)
covariant.type.contravariant.position.of.method=Covariant type {0} occurs in contravariant position in type {1} of method {2}
covariant.type.contravariant.position.of.value=Covariant type {0} occurs in contravariant position in type {1} of value {2}
covariant.type.invariant.position.of.method=Covariant type {0} occurs in invariant position in type {1} of method {2}
covariant.type.invariant.position.of.value=Covariant type {0} occurs in invariant position in type {1} of value {2}
contravariant.type.covariant.position.of.method=Contravariant type {0} occurs in covariant position in type {1} of method {2}
contravariant.type.covariant.position.of.value=Contravariant type {0} occurs in covariant position in type {1} of value {2}
contravariant.type.invariant.position.of.method=Contravariant type {0} occurs in invariant position in type {1} of method {2}
contravariant.type.invariant.position.of.value=Contravariant type {0} occurs in invariant position in type {1} of value {2}
abstract.member.not.have.private.modifier=Abstract member may not have private modifier
missing.arguments.for.method=Missing arguments for method {0} and is not a partially applied function. Add more arguments or insert a placeholder.
lower.bound.conform.to.upper=Lower bound doesn't conform to upper bound
########################################################################################################################
# Scala actions
########################################################################################################################
import.with=Import ''{0}''
import.class=Import class
title.scala.settings=Scala
report.highlighting.error.fix=Report highlighting error...
implement.methods.fix=Implement methods
add.modifier.fix=Add ''{0}'' modifier
remove.modifier.fix=Remove ''{0}'' modifier
specify.return.type.explicitly=Specify result &type explicitly
add.override.modifier=Add &override modifier
element.of.trait=of trait
element.of.class=of class
element.method=method
label.method=Method {0}
find.usages.method.has.supers= Method {0} overrides/implements some base method.\n\
  Do you want to find usages for the base method?
method.has.supers= Method {0} overrides/implements some base method, rename it as well?
remove.explicit.val=Remove explicit 'val'
xml.delete.unmatched.tag=Delete Unmatched Tag
xml.rename.opening.tag=Rename Opening Tag
xml.rename.closing.tag=Rename Closing Tag
create.scaladoc.stub.action=Create ScalaDoc stub action
wrap.in.option.name=Wrap in Option
wrap.in.option.hint=Wrap expression in Option(...)?
convert.java.to.scala.collection.hint=Convert to Scala collection using scala.collection.JavaConverters?
convert.java.to.scala.collection.name=Convert to Scala collection
convert.scala.to.java.collection.hint=Convert to Java collection using scala.collection.JavaConverters?
convert.scala.to.java.collection.name=Convert to Java collection
choose.expression.for=Choose Expression for {0}
rename.companion.module=Rename companion {0}

unwrap.case.clause=Unwrap case clause
remove.case.clause=Remove case clause
unwrap.try.with.finally=Unwrap try / finally
unwrap.finally=Unwrap finally
remove.finally=Remove finally block
remove.catch=Remove catch block
unwrap.interpolated.string.injection=Unwrap interpolated string injection
########################################################################################################################
# Scala facet
########################################################################################################################
maven.repository.presentable.name=Maven repository
config.display.name=Configuration
scala.facet.title=Sca&la
config.scala.libraries=Configure Scala libraries

scala.config.label=Scala installation directory
scala.config.dscr=Please specify path to Scala installation directory
scala.config.noscala.title=Scala Configuration Error
scala.config.download.link=http://www.scala-lang.org/downloads/
scala.config.download.link.label=Scala is available for download on:
scala.config.compiler.library=Scala comp&iler library:
scala.config.sdk.library=Scala &SDK library:
scala.config.sdk.space.hint=Several paths must be separated by file separator - '';''
scala.config.take.compiler.from.settings=Use Scala compiler &libraries from specified jars
scala.config.take.relative.path=Use relative path towards the project root
error.scala.path.not.valid=Scala path is not valid

scala.config.project.template.name=Non-SBT
scala.config.project.template.description=Module for developing Scala Application
scala.config.project.settings.title=Scala Settings
scala.config.module.name=Scala Module
scala.config.module.description=Create Scala Module

##########################################################################################################################
# SDK & compilation
########################################################################################################################

no.java.sdk=No java SDK configured
cannot.compile.scala.files.no.facet=Please attach a Scala facet to module.
cannot.compile.scala.files.no.compiler=Please, specify compiler library in Scala facet.
cannot.compile.scala.files.compiler.problem=Please, adjust compiler library in Scala facet: {0}.
cannot.compile.scala.files.no.sdk=Please, set up Java SDK for module ''{0}''.
cannot.compile.scala.files.no.sdk.mult=Please, Set up Java SDK for modules ''{0}''.
cannot.compile=Cannot compile Scala files
debug.option=Enable debug stacktrace
scalac.compiler.name=Scalac
javac.error.tools.jar.missing=Cannot obtain path javac classes for JDK {0}.\nUpdate JDK configuration.
javac.error.unknown.jdk.version=Cannot determine version for JDK {0}.\nUpdate JDK configuration.
different.scala.sdk.in.modules=Dependent modules must have equal Scala SDK versions
scala.compiler.description=Scala compiler
scala.debug.disable.specific.methods=Do not step &into specific Scala classes
scala.debug.caption=Scala
jtype.is.not.found=Cannot compile Scala files.\nch.epfl.lamp.fjbg.JType class is not found. \nPlease, attach appropriate jar to the module ''{0}''.

########################################################################################################################
# Facet configuration
########################################################################################################################
scala.sdk.configuration=Scala SDK configuration
new.button.label=New
scala.sdk.configuration.label=<html><b>Scala SDK:</b><br>Choose Scala SDK specific for this module</html>
add.new.scala.lib=New Scala SDK
invalid.scala.sdk.path.text=Wrong path specified
duplicate.scala.lib.version=Duplicated Scala SDK version
duplicate.scala.lib.version.add=Add one more Scala SDK of version {0}?
scala.sdk.combo.box.project.item=<No Scala SDK>
no.scala.facet=Scala Facet expected
new.scala.facet.detected=Scala Facet detected
invalid.scala.sdk.path.message=Invalid path to Scala SDK
introduce.variable.title=Introduce Variable
introduce.parameter.title=Introduce Parameter
introduce.field.title=Introduce Field
extract.method.title=Extract Method
extract.local.method=Extract local method in {0}
press.escape.to.remove.the.highlighting=Press escape to remove the highlighting
facet.create.lib.title=Create Scala library
facet.create.project.lib=Create &Project-level Scala library ''{0}''
facet.create.application.lib=Create &Application-level Scala library ''{0}''

facet.setting.exclude.compiler.from.cp=Exclude Scala Com&piler library from module scope
facet.setting.exclude.library.from.cp=Exclude Scala SDK &library from module scope

########################################################################################################################
# File Templates
########################################################################################################################
file.template.group.title.scala=Scala

# class
newclass.dlg.prompt=Enter name for new Scala Class
newclass.dlg.title=New Scala Class
newclass.menu.action.text=Scala Class
newclass.menu.action.description=Creates new Scala Class
newclass.command.name=Create Scala Class
newclass.progress.text=Creating Scala Class ''{0}''
# worksheet
newworksheet.dlg.prompt=Enter name for new Scala Worksheet
newworksheet.dlg.title=New Scala Worksheet
newworksheet.menu.action.text=Scala Worksheet
newworksheet.menu.action.description=Creates new Scala Worksheet
newworksheet.command.name=Create Scala Worksheet
newworksheet.progress.text=Creating Scala Worksheet ''{0}''
#object
newobject.dlg.prompt=Enter name for new Scala object
newobject.dlg.title=New Scala Object
newobject.menu.action.text=Scala Object
newobject.menu.action.description=Creates new Scala Object
newobject.command.name=Create Scala Object
newobject.progress.text=Creating Scala Object ''{0}''
#trait
newtrait.dlg.prompt=Enter name for new Scala Trait
newtrait.dlg.title=New Scala Trait
newtrait.menu.action.text=Scala Trait
newtrait.menu.action.description=Creates new Scala Trait
newtrait.command.name=Create Scala Trait
newtrait.progress.text=Creating Scala Trait ''{0}''

scala.compiler.option.additional.command.line.parameters=Scala compiler additional command line parameters

########################################################################################################################
# Decompiler output
########################################################################################################################
psi.decompiled.text.header=\
  // IntelliJ API decompiler for Scala language\n\
  // Stub source generated from a class file\n\
  // Implementation of functions is not available

########################################################################################################################
# Scala compiler settings
########################################################################################################################
scala.compiler.heap.size=Maximum heap size (MB):
scala.compiler.cmd.line.params=Command line parameters
scala.compiler.use.deprecation=Compile @&deprecated annotations
scala.compiler.scalac.first=Compile &Scala files first
scala.compiler.show.unchecked=Compile @&unchecked annotations
scala.compiler.generate.no.warnings=Generate no &warnings
scala.compiler.optimize=&Optimise bytecode
scala.compiler.no.generics=Suppress Scala &generic signatures

########################################################################################################################
# Scala Type checked error messages
########################################################################################################################
no.right.operand.found=No right operand found
cannot.resolve.infix.operator=Cannot resolve infix operator
circular.dependency.detected=Circular dependency detected for the type alias ''{0}''
no.type.inferred=No type inferred for the expression ''{0}''
no.type.element.found=No type lement found in ''{0}''
nothing.to.type=Nothing to type
no.result.expression.found=No result expression found

########################################################################################################################
# Scala control flow errors
########################################################################################################################
unreachable.expression=Unreachable statement

########################################################################################################################
# Scala type info
########################################################################################################################
type.info=Type Info

########################################################################################################################
# Scala intentions
########################################################################################################################

intention.type.annotation.toggle.family=Toggle Type Annotation

intention.type.annotation.function.add.text=Add type annotation to function definition
intention.type.annotation.function.remove.text=Remove type annotation from function definition

intention.type.annotation.value.add.text=Add type annotation to value definition
intention.type.annotation.value.remove.text=Remove type annotation from value definition

intention.type.annotation.variable.add.text=Add type annotation to variable definition
intention.type.annotation.variable.remove.text=Remove type annotation from variable definition

intention.type.annotation.pattern.add.text=Add type annotation to pattern definition
intention.type.annotation.pattern.remove.text=Remove type annotation from pattern definition

intention.type.annotation.parameter.add.text=Add type annotation to parameter
intention.type.annotation.parameter.remove.text=Remove type annotation from parameter

########################################################################################################################
# Scala test runner display name patterns
########################################################################################################################
test.in.scope.specs.presentable.text=Specs in ''{0}''
test.in.scope.specs2.presentable.text=Specs2 in ''{0}''
test.in.scope.scalatest.presentable.text=ScalaTests in ''{0}''
test.in.scope.utest.presentable.text=UTests in ''{0}''

########################################################################################################################
# Scala code inspections
########################################################################################################################
equals.between.inconvertible.types.display.name=Equality test between objects of inconvertible types
equals.between.inconvertible.types.description=Detects equality tests that will always return false, because the static type of the operands are inconvertible.
equals.between.inconvertible.types.problem.descriptor=Equality test between objects of inconvertible types ''{0}'' and ''{1}'' #loc
########################################################################################################################
# Scala options
########################################################################################################################
multi.line.string.support.option=Multi-line strings support:
multi.line.string.support.chooser.label=Level:
multi.line.string.support.margin.char.label=Margin char:
multi.line.string.support.none=None
multi.line.string.support.enter=Quotes on new line
multi.line.string.support.all=Insert margin char
collection.type.highlighting.option=Collection type highlighting:
multi.line.string.settings.panel=Multi-line strings
multi.line.string.margin.char.indent=Margin char indent:
multi.line.string.opening.quotes.on.new.line=Opening quotes on new line
multi.line.string.keep.opening.quotes=Keep opening quotes
multi.line.string.process.margin.on.copy.paste=Strip/Insert margin on copy/paste
enumerator.val.keyword.deprecated='val' keyword in enumerators is deprecated
generator.val.keyword.removed=Expected pattern, but 'val' was found
friendly.collection.debug.start.index=Collection start index
friendly.collection.debug.end.index=Collection end index
friendly.collection.display.enabled=Friendly display of Scala collections in debugger
friendly.collection.do.not.display.streams=Do not expand Streams
friendly.object.ref.display=Friendly display of ObjectRef in debugger
move.to.inner.is.not.supported.title=Refactoring is not supported
move.to.inner.is.not.supported=Move class to inner is not supported for Scala
move.with.companion=Move together with the companion
insert.pair.multiline.quotes=Insert pair quotes for multiline string
########################################################################################################################
# Worksheet buttons
########################################################################################################################
worksheet.execute.button=Evaluate worksheet
worksheet.clear.button=Clear results
worksheet.copy.button=Copy worksheet
worksheet.stop.button=Stop worksheet execution
worksheet.change.make.button=Make project before run
find.usages.implementing.type.definition=Implementing Type Definitions
find.usages.companin.module=Companion module usages
find.what.members.usages.checkbox=Usages of &members
find.what.implementing.type.definitions.checkbox=Implementing type &definitions
find.what.companion.module.checkbox=Usages of &companion module
forward.reference.detected=Wrong forward reference
suspicicious.forward.reference.template.body=Suspicious forward reference in class

########################################################################################################################
# Refactorings
########################################################################################################################
introduce.variable.declare.as.var=Declare with var
introduce.variable.specify.type.explicitly=Specify type explicitly
introduce.variable.identifier.is.not.valid=Identifier is not valid
rename.special.method.title=This method can not be renamed
rename.special.method.rename.class=Rename containing {0}
rename.cancel=Cancel
rename.aliased.title=Renaming of import aliases is not supported
rename.aliased.rename.actual=Rename actual element
rename.getters.and.setters.title=Function has getters or setters with same name. Rename them as well?
introduce.field.choose.class=Choose class for Introduce Field
rename.all.base.members=Rename all base members
rename.base.member=Rename base member
rename.only.current.member=Rename only current member
rename.has.multiple.base.members={0} has multiple base members
rename.only.in=Rename only in {0} {1}
extract.trait.title=Extract trait
extract.trait.name.not.specified=No trait name specified
extract.trait.top.label.text=Extract trait from:
extract.trait.name=Trait name:
extract.trait.package.label=Package for new trait:
private.member.cannot.be.used.in.extracted.member=Private member {0} cannot be used in the extracted member {1}
member.of.anonymous.class.cannot.be.used.in.extracted.member=Member {0} of an anonymous class cannot be used in the extracted member {1}
super.reference.used.in.extracted.member=Extracted member {0} has reference to super, but extracted trait will not have a base class
type.parameters.for.self.type.not.supported=Extracted trait will have {0} as a self type, but identification of it's type parameters is not supported
members.to.extract=Members to extract
extract.abstracts=extract abstracts

rename.local.id=scala.rename.local
rename.member.id=scala.rename.member
move.file.id=scala.move.file
move.class.id=scala.move.class
introduce.variable.id=scala.introduce.variable
introduce.field.id=scala.introduce.field
introduce.parameter.id=scala.introduce.parameter
extract.method.id=scala.extract.method
extract.trait.id=scala.extract.trait
inline.id=scala.inline

